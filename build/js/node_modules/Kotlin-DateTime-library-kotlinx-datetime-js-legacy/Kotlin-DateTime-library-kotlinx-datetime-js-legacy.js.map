{"version":3,"file":"Kotlin-DateTime-library-kotlinx-datetime-js-legacy.js","sources":["../../../../../core/common/src/DateTimePeriod.kt","js/src/kotlin/math.kt","src/kotlin/text/StringBuilder.kt","../../../../../core/common/src/DateTimeUnit.kt","../../../../../core/common/src/Instant.kt","../../../../../core/common/src/math.kt","../../../../../core/commonMain/src/kotlinx/serialization/encoding/Decoding.kt","../../../../../core/commonMain/src/kotlinx/serialization/descriptors/SerialDescriptors.kt","../../../../../core/commonMain/src/kotlinx/serialization/Serializers.kt","../../../../../core/commonMain/src/kotlinx/serialization/internal/Platform.common.kt","common/src/generated/_Strings.kt","../../../../../core/common/src/Clock.kt","src/kotlin/util/Standard.kt","js/src/kotlin/text/string.kt","src/kotlin/util/Preconditions.kt","../../../../../core/common/src/DayOfWeek.kt","../../../../../core/common/src/Exceptions.kt","../../../../../core/common/src/LocalDate.kt","../../../../../core/common/src/LocalDateTime.kt","../../../../../core/common/src/Month.kt","../../../../../core/common/src/TimeZone.kt","../../../../../core/common/src/UtcOffset.kt","../../../../../core/common/src/serializers/DateTimePeriodSerializers.kt","../../../../../core/commonMain/src/kotlinx/serialization/encoding/Encoding.kt","../../../../../core/common/src/serializers/DateTimeUnitSerializers.kt","../../../../../core/common/src/serializers/DayOfWeekSerializers.kt","../../../../../core/common/src/serializers/InstantSerializers.kt","../../../../../core/common/src/serializers/LocalDateSerializers.kt","../../../../../core/common/src/serializers/LocalDateTimeSerializers.kt","../../../../../core/common/src/serializers/MonthSerializers.kt","../../../../../core/common/src/serializers/TimeZoneSerializers.kt","../../../../../core/js/src/DayOfWeek.kt","../../../../../core/js/src/Instant.kt","src/kotlin/time/Duration.kt","../../../../../core/js/src/JSJodaExceptions.kt","../../../../../core/js/src/LocalDate.kt","../../../../../core/js/src/LocalDateTime.kt","../../../../../core/js/src/Month.kt","../../../../../core/js/src/TimeZone.kt","../../../../../core/js/src/UtcOffset.kt","../../../../../core/js/src/mathJs.kt"],"sourcesContent":[null,"/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.JsMath as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x)\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x)\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x)\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n@file:Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n\npackage kotlin.text\n\nimport kotlin.contracts.*\n\n/**\n * A mutable sequence of characters.\n *\n * String builder can be used to efficiently perform multiple string manipulation operations.\n */\nexpect class StringBuilder : Appendable, CharSequence {\n    /** Constructs an empty string builder. */\n    constructor()\n\n    /** Constructs an empty string builder with the specified initial [capacity]. */\n    constructor(capacity: Int)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] char sequence. */\n    constructor(content: CharSequence)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] string. */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    constructor(content: String)\n\n    override val length: Int\n\n    override operator fun get(index: Int): Char\n\n    override fun subSequence(startIndex: Int, endIndex: Int): CharSequence\n\n    override fun append(value: Char): StringBuilder\n    override fun append(value: CharSequence?): StringBuilder\n    override fun append(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder\n\n    /**\n     * Reverses the contents of this string builder and returns this instance.\n     *\n     * Surrogate pairs included in this string builder are treated as single characters.\n     * Therefore, the order of the high-low surrogates is never reversed.\n     *\n     * Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation.\n     * For example, reversing `\"\\uDC00\\uD800\"` produces `\"\\uD800\\uDC00\"` which is a valid surrogate pair.\n     */\n    fun reverse(): StringBuilder\n\n    /**\n     * Appends the string representation of the specified object [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    fun append(value: Any?): StringBuilder\n\n    /**\n     * Appends the string representation of the specified boolean [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: Boolean): StringBuilder\n\n    /**\n     * Appends characters in the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at the index 0.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun append(value: CharArray): StringBuilder\n\n    /**\n     * Appends the specified string [value] to this string builder and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are appended.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: String?): StringBuilder\n\n    /**\n     * Returns the current capacity of this string builder.\n     *\n     * The capacity is the maximum length this string builder can have before an allocation occurs.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    @Deprecated(\"Obtaining StringBuilder capacity is not supported in JS and common code.\", level = DeprecationLevel.ERROR)\n    fun capacity(): Int\n\n    /**\n     * Ensures that the capacity of this string builder is at least equal to the specified [minimumCapacity].\n     *\n     * If the current capacity is less than the [minimumCapacity], a new backing storage is allocated with greater capacity.\n     * Otherwise, this method takes no action and simply returns.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun ensureCapacity(minimumCapacity: Int)\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string],\n     * starting at the specified [startIndex].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string].\n     * The last occurrence of empty string `\"\"` is considered to be at the index equal to `this.length`.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string],\n     * starting from the specified [startIndex] toward the beginning.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Inserts the string representation of the specified boolean [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Boolean): StringBuilder\n\n    /**\n     * Inserts the specified character [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Char): StringBuilder\n\n    /**\n     * Inserts characters in the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] character array, starting at [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharArray): StringBuilder\n\n    /**\n     * Inserts characters in the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which characters are inserted. If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharSequence?): StringBuilder\n\n    /**\n     * Inserts the string representation of the specified object [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Any?): StringBuilder\n\n    /**\n     * Inserts the string [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: String?): StringBuilder\n\n    /**\n     *  Sets the length of this string builder to the specified [newLength].\n     *\n     *  If the [newLength] is less than the current length, it is changed to the specified [newLength].\n     *  Otherwise, null characters '\\u0000' are appended to this string builder until its length is less than the [newLength].\n     *\n     *  Note that in Kotlin/JS [set] operator function has non-constant execution time complexity.\n     *  Therefore, increasing length of this string builder and then updating each character by index may slow down your program.\n     *\n     *  @throws IndexOutOfBoundsException or [IllegalArgumentException] if [newLength] is less than zero.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun setLength(newLength: Int)\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [length] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int): String\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [endIndex] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int, endIndex: Int): String\n\n    /**\n     * Attempts to reduce storage used for this string builder.\n     *\n     * If the backing storage of this string builder is larger than necessary to hold its current contents,\n     * then it may be resized to become more space efficient.\n     * Calling this method may, but is not required to, affect the value of the [capacity] property.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun trimToSize()\n}\n\n\n/**\n * Clears the content of this string builder making it empty and returns this instance.\n *\n * @sample samples.text.Strings.clearStringBuilder\n */\n@SinceKotlin(\"1.3\")\npublic expect fun StringBuilder.clear(): StringBuilder\n\n/**\n * Sets the character at the specified [index] to the specified [value].\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect operator fun StringBuilder.set(index: Int, value: Char)\n\n/**\n * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to replace.\n * @param endIndex the end (exclusive) of the range to replace.\n * @param value the string to replace with.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder\n\n/**\n * Removes the character at the specified [index] from this string builder and returns this instance.\n *\n * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n *\n * @param index the index of `Char` to remove.\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteAt(index: Int): StringBuilder\n\n/**\n * Removes characters in the specified range from this string builder and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to remove.\n * @param endIndex the end (exclusive) of the range to remove.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteRange(startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Copies characters from this string builder into the [destination] character array.\n *\n * @param destination the array to copy to.\n * @param destinationOffset the position in the array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n *  or when that index is out of the [destination] array indices range.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length)\n\n/**\n * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n *\n * Characters are appended in order, starting at specified [startIndex].\n *\n * @param value the array from which characters are appended.\n * @param startIndex the beginning (inclusive) of the subarray to append.\n * @param endIndex the end (exclusive) of the subarray to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in same order as in the [value] array, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the array from which characters are inserted.\n * @param startIndex the beginning (inclusive) of the subarray to insert.\n * @param endIndex the end (exclusive) of the subarray to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the character sequence from which a subsequence is inserted.\n * @param startIndex the beginning (inclusive) of the subsequence to insert.\n * @param endIndex the end (exclusive) of the subsequence to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n@Deprecated(\"Use append(value: Any?) instead\", ReplaceWith(\"append(value = obj)\"), DeprecationLevel.WARNING)\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.append(obj: Any?): StringBuilder = this.append(obj)\n\n/**\n * Builds new string by populating newly created [StringBuilder] using provided [builderAction]\n * and then converting it to [String].\n */\n@kotlin.internal.InlineOnly\npublic inline fun buildString(builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder().apply(builderAction).toString()\n}\n\n/**\n * Builds new string by populating newly created [StringBuilder] initialized with the given [capacity]\n * using provided [builderAction] and then converting it to [String].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun buildString(capacity: Int, builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder(capacity).apply(builderAction).toString()\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: String?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: Any?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/** Appends a line feed character (`\\n`) to this StringBuilder. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(): StringBuilder = append('\\n')\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharSequence?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: String?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Any?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharArray): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Char): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Boolean): StringBuilder = append(value).appendLine()\n",null,null,null,null,null,null,null,"/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns a character at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharSequence.elementAt(index: Int): Char\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first character.\n * @throws [NoSuchElementException] if the char sequence is empty.\n */\npublic fun CharSequence.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate].\n * @throws [NoSuchElementException] if no such character is found.\n */\npublic inline fun CharSequence.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to characters of this char sequence in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <R : Any> CharSequence.firstNotNullOf(transform: (Char) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the char sequence was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to characters of this char sequence in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <R : Any> CharSequence.firstNotNullOfOrNull(transform: (Char) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first character, or `null` if the char sequence is empty.\n */\npublic fun CharSequence.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if character was not found.\n */\npublic inline fun CharSequence.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun CharSequence.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns index of the first character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last character.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n * \n * @sample samples.text.Strings.last\n */\npublic fun CharSequence.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last character matching the given [predicate].\n * \n * @throws NoSuchElementException if no such character is found.\n * \n * @sample samples.text.Strings.last\n */\npublic inline fun CharSequence.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the last character, or `null` if the char sequence is empty.\n * \n * @sample samples.text.Strings.last\n */\npublic fun CharSequence.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[length - 1]\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.text.Strings.last\n */\npublic inline fun CharSequence.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random character from this char sequence.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharSequence.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns a random character from this char sequence, or `null` if this char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness, or `null` if this char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharSequence.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns the single character, or throws an exception if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.single(): Char {\n    return when (length) {\n        0 -> throw NoSuchElementException(\"Char sequence is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Char sequence has more than one element.\")\n    }\n}\n\n/**\n * Returns the single character matching the given [predicate], or throws exception if there is no or more than one matching character.\n */\npublic inline fun CharSequence.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Char sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single character, or `null` if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.singleOrNull(): Char? {\n    return if (length == 1) this[0] else null\n}\n\n/**\n * Returns the single character matching the given [predicate], or `null` if character was not found or more than one character was found.\n */\npublic inline fun CharSequence.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a subsequence of this char sequence with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.drop(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.drop(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.dropLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a string with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.dropLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return substring(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropWhile(predicate: (Char) -> Boolean): String {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return substring(index)\n    return \"\"\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * \n * @sample samples.text.Strings.filter\n */\npublic inline fun CharSequence.filter(predicate: (Char) -> Boolean): CharSequence {\n    return filterTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * \n * @sample samples.text.Strings.filter\n */\npublic inline fun String.filter(predicate: (Char) -> Boolean): String {\n    return filterTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun CharSequence.filterIndexed(predicate: (index: Int, Char) -> Boolean): CharSequence {\n    return filterIndexedTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun String.filterIndexed(predicate: (index: Int, Char) -> Boolean): String {\n    return filterIndexedTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : Appendable> CharSequence.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that do not match the given [predicate].\n * \n * @sample samples.text.Strings.filterNot\n */\npublic inline fun CharSequence.filterNot(predicate: (Char) -> Boolean): CharSequence {\n    return filterNotTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that do not match the given [predicate].\n * \n * @sample samples.text.Strings.filterNot\n */\npublic inline fun String.filterNot(predicate: (Char) -> Boolean): String {\n    return filterNotTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : Appendable> CharSequence.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.append(element)\n    return destination\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : Appendable> CharSequence.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (index in 0 until length) {\n        val element = get(index)\n        if (predicate(element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at the specified range of [indices].\n */\npublic fun CharSequence.slice(indices: IntRange): CharSequence {\n    if (indices.isEmpty()) return \"\"\n    return subSequence(indices)\n}\n\n/**\n * Returns a string containing characters of the original string at the specified range of [indices].\n */\npublic fun String.slice(indices: IntRange): String {\n    if (indices.isEmpty()) return \"\"\n    return substring(indices)\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at specified [indices].\n */\npublic fun CharSequence.slice(indices: Iterable<Int>): CharSequence {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return \"\"\n    val result = StringBuilder(size)\n    for (i in indices) {\n        result.append(get(i))\n    }\n    return result\n}\n\n/**\n * Returns a string containing characters of the original string at specified [indices].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.slice(indices: Iterable<Int>): String {\n    return (this as CharSequence).slice(indices).toString()\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.take(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a string containing the first [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.take(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing the last [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.takeLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return subSequence(length - n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string containing the last [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.takeLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return substring(length - n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return subSequence(index + 1, length)\n        }\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return substring(index + 1)\n        }\n    }\n    return this\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return subSequence(0, index)\n        }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeWhile(predicate: (Char) -> Boolean): String {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return substring(0, index)\n        }\n    return this\n}\n\n/**\n * Returns a char sequence with characters in reversed order.\n */\npublic fun CharSequence.reversed(): CharSequence {\n    return StringBuilder(this).reverse()\n}\n\n/**\n * Returns a string with characters in reversed order.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.reversed(): String {\n    return (this as CharSequence).reversed().toString()\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to characters of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associate\n */\npublic inline fun <K, V> CharSequence.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the characters from the given char sequence indexed by the key\n * returned from [keySelector] function applied to each character.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateBy\n */\npublic inline fun <K> CharSequence.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateByWithValueTransform\n */\npublic inline fun <K, V> CharSequence.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each character of the given char sequence\n * and value is the character itself.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each character of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are characters from the given char sequence and values are\n * produced by the [valueSelector] function applied to each character.\n * \n * If any two characters are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V> CharSequence.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(length.coerceAtMost(128)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each character of the given char sequence,\n * where key is the character itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two characters are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.text.Strings.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V, M : MutableMap<in Char, in V>> CharSequence.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all characters to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharSequence.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all characters.\n */\npublic fun CharSequence.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(length.coerceAtMost(128))))\n}\n\n/**\n * Returns a [List] containing all characters.\n */\npublic fun CharSequence.toList(): List<Char> {\n    return when (length) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a new [MutableList] filled with all characters of this char sequence.\n */\npublic fun CharSequence.toMutableList(): MutableList<Char> {\n    return toCollection(ArrayList<Char>(length))\n}\n\n/**\n * Returns a [Set] of all characters.\n * \n * The returned set preserves the element iteration order of the original char sequence.\n */\npublic fun CharSequence.toSet(): Set<Char> {\n    return when (length) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(length.coerceAtMost(128))))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character of original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> CharSequence.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character\n * and its index in the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.flatMapIndexed(transform: (index: Int, Char) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character\n * and its index in the original char sequence, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapIndexedTo(destination: C, transform: (index: Int, Char) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character of original char sequence, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and returns a map where each group key is associated with a list of corresponding characters.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharSequence.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharSequence.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and puts to the [destination] map each group key associated with a list of corresponding characters.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a char sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each character.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K> CharSequence.groupingBy(crossinline keySelector: (Char) -> K): Grouping<Char, K> {\n    return object : Grouping<Char, K> {\n        override fun sourceIterator(): Iterator<Char> = this@groupingBy.iterator()\n        override fun keyOf(element: Char): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character in the original char sequence.\n * \n * @sample samples.text.Strings.map\n */\npublic inline fun <R> CharSequence.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R> CharSequence.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any> CharSequence.mapIndexedNotNull(transform: (index: Int, Char) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapIndexedNotNullTo(destination: C, transform: (index: Int, Char) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character in the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <R : Any> CharSequence.mapNotNull(transform: (Char) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character in the original char sequence\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapNotNullTo(destination: C, transform: (Char) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character of the original char sequence\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each character of the original char sequence\n * into an [IndexedValue] containing the index of that character and the character itself.\n */\npublic fun CharSequence.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns `true` if all characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharSequence.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if char sequence has at least one character.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharSequence.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one character matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharSequence.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the length of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.count(): Int {\n    return length\n}\n\n/**\n * Returns the number of characters matching the given [predicate].\n */\npublic inline fun CharSequence.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes a character and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each character.\n */\npublic inline fun CharSequence.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the action on the character.\n */\npublic inline fun CharSequence.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharSequence.max(): Char? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> CharSequence.maxBy(selector: (Char) -> R): Char? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first character yielding the largest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.maxByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.maxOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.maxOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.maxOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest character or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.maxOrNull(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharSequence.maxWith(comparator: Comparator<in Char>): Char? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first character having the largest value according to the provided [comparator] or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.maxWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharSequence.min(): Char? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> CharSequence.minBy(selector: (Char) -> R): Char? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first character yielding the smallest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.minByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.minOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.minOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.minOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.minOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest character or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.minOrNull(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharSequence.minWith(comparator: Comparator<in Char>): Char? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first character having the smallest value according to the provided [comparator] or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.minWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the char sequence has no characters.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharSequence.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharSequence.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each character and returns the char sequence itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S : CharSequence> S.onEach(action: (Char) -> Unit): S {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character,\n * and returns the char sequence itself afterwards.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the action on the character.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S : CharSequence> S.onEachIndexed(action: (index: Int, Char) -> Unit): S {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and a character,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharSequence.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value and the character itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharSequence.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value and the character itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.reduceIndexedOrNull(operation: (index: Int, acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and a character,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharSequence.reduceOrNull(operation: (acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes a character and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharSequence.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharSequence.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.reduceRightIndexedOrNull(operation: (index: Int, Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes a character and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharSequence.reduceRightOrNull(operation: (Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R> CharSequence.runningFold(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(length + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R> CharSequence.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(length + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with the first character of this char sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.runningReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(length).apply { add(accumulator) }\n    for (index in 1 until length) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with the first character of this char sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.runningReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(length).apply { add(accumulator) }\n    for (index in 1 until length) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <R> CharSequence.scan(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <R> CharSequence.scanIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharSequence.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharSequence.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Splits this char sequence into a list of strings each not exceeding the given [size].\n * \n * The last string in the resulting list may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunked(size: Int): List<String> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunked(size: Int, transform: (CharSequence) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits this char sequence into a sequence of strings each not exceeding the given [size].\n * \n * The last string in the resulting sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunkedSequence(size: Int): Sequence<String> {\n    return chunkedSequence(size) { it.toString() }\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransformToSequence\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunkedSequence(size: Int, transform: (CharSequence) -> R): Sequence<R> {\n    return windowedSequence(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits the original char sequence into pair of char sequences,\n * where *first* char sequence contains characters for which [predicate] yielded `true`,\n * while *second* char sequence contains characters for which [predicate] yielded `false`.\n * \n * @sample samples.text.Strings.partition\n */\npublic inline fun CharSequence.partition(predicate: (Char) -> Boolean): Pair<CharSequence, CharSequence> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original string into pair of strings,\n * where *first* string contains characters for which [predicate] yielded `true`,\n * while *second* string contains characters for which [predicate] yielded `false`.\n * \n * @sample samples.text.Strings.partition\n */\npublic inline fun String.partition(predicate: (Char) -> Boolean): Pair<String, String> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first.toString(), second.toString())\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<String> {\n    return windowed(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    val thisSize = this.length\n    val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n    val result = ArrayList<R>(resultCapacity)\n    var index = 0\n    while (index in 0 until thisSize) {\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > thisSize) { if (partialWindows) thisSize else break } else end\n        result.add(transform(subSequence(index, coercedEnd)))\n        index += step\n    }\n    return result\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<String> {\n    return windowedSequence(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): Sequence<R> {\n    checkWindowSizeStep(size, step)\n    val windows = (if (partialWindows) indices else 0 until length - size + 1) step step\n    return windows.asSequence().map { index ->\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > length) length else end\n        transform(subSequence(index, coercedEnd))\n    }\n}\n\n/**\n * Returns a list of pairs built from the characters of `this` and the [other] char sequences with the same index\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zip\n */\npublic infix fun CharSequence.zip(other: CharSequence): List<Pair<Char, Char>> {\n    return zip(other) { c1, c2 -> c1 to c2 }\n}\n\n/**\n * Returns a list of values built from the characters of `this` and the [other] char sequences with the same index\n * using the provided [transform] function applied to each pair of characters.\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zipWithTransform\n */\npublic inline fun <V> CharSequence.zip(other: CharSequence, transform: (a: Char, b: Char) -> V): List<V> {\n    val length = minOf(this.length, other.length)\n    val list = ArrayList<V>(length)\n    for (i in 0 until length) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.zipWithNext(): List<Pair<Char, Char>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <R> CharSequence.zipWithNext(transform: (a: Char, b: Char) -> R): List<R> {\n    val size = length - 1\n    if (size < 1) return emptyList()\n    val result = ArrayList<R>(size)\n    for (index in 0 until size) {\n        result.add(transform(this[index], this[index + 1]))\n    }\n    return result\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asIterable(): Iterable<Char> {\n    if (this is String && isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asSequence(): Sequence<Char> {\n    if (this is String && isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n",null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString() instead\", ReplaceWith(\"chars.concatToString()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic actual fun String(chars: CharArray): String {\n    var result = \"\"\n    for (char in chars) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n *\n * @throws IndexOutOfBoundsException if either [offset] or [length] are less than zero\n * or `offset + length` is out of [chars] array bounds.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString(startIndex, endIndex) instead\", ReplaceWith(\"chars.concatToString(offset, offset + length)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    if (offset < 0 || length < 0 || chars.size - offset < length)\n        throw IndexOutOfBoundsException(\"size: ${chars.size}; offset: $offset; length: $length\")\n    var result = \"\"\n    for (index in offset until offset + length) {\n        result += chars[index]\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] into a String.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun CharArray.concatToString(): String {\n    var result = \"\"\n    for (char in this) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] or its subrange into a String.\n *\n * @param startIndex the beginning (inclusive) of the subrange of characters, 0 by default.\n * @param endIndex the end (exclusive) of the subrange of characters, size of this array by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.concatToString(startIndex: Int = 0, endIndex: Int = this.size): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    var result = \"\"\n    for (index in startIndex until endIndex) {\n        result += this[index]\n    }\n    return result\n}\n\n/**\n * Returns a [CharArray] containing characters of this string.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.toCharArray(): CharArray {\n    return CharArray(length) { get(it) }\n}\n\n/**\n * Returns a [CharArray] containing characters of this string or its substring.\n *\n * @param startIndex the beginning (inclusive) of the substring, 0 by default.\n * @param endIndex the end (exclusive) of the substring, length of this string by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.toCharArray(startIndex: Int = 0, endIndex: Int = this.length): CharArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return CharArray(endIndex - startIndex) { get(startIndex + it) }\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array.\n *\n * Malformed byte sequences are replaced by the replacement char `\\uFFFD`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun ByteArray.decodeToString(): String {\n    return decodeUtf8(this, 0, size, false)\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array or its subrange.\n *\n * @param startIndex the beginning (inclusive) of the subrange to decode, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to decode, size of this array by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char `\\uFFFD`.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if the byte array contains malformed UTF-8 byte sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.decodeToString(\n    startIndex: Int = 0,\n    endIndex: Int = this.size,\n    throwOnInvalidSequence: Boolean = false\n): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    return decodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Encodes this string to an array of bytes in UTF-8 encoding.\n *\n * Any malformed char sequence is replaced by the replacement byte sequence.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.encodeToByteArray(): ByteArray {\n    return encodeUtf8(this, 0, length, false)\n}\n\n/**\n * Encodes this string or its substring to an array of bytes in UTF-8 encoding.\n *\n * @param startIndex the beginning (inclusive) of the substring to encode, 0 by default.\n * @param endIndex the end (exclusive) of the substring to encode, length of this string by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed char sequence or replace.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if this string contains malformed char sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.encodeToByteArray(\n    startIndex: Int = 0,\n    endIndex: Int = this.length,\n    throwOnInvalidSequence: Boolean = false\n): ByteArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return encodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@Deprecated(\"Use uppercase() instead.\", ReplaceWith(\"uppercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun String.uppercase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@Deprecated(\"Use lowercase() instead.\", ReplaceWith(\"lowercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun String.lowercase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        var start = 0\n        while (true) {\n            val end = minOf(start + 16, min)\n            var s1 = this.substring(start, end)\n            var s2 = other.substring(start, end)\n            if (s1 != s2) {\n                s1 = s1.uppercase()\n                s2 = s2.uppercase()\n                if (s1 != s2) {\n                    s1 = s1.lowercase()\n                    s2 = s2.lowercase()\n                    if (s1 != s2) {\n                        return s1.compareTo(s2)\n                    }\n                }\n            }\n            if (end == min) break\n            start = end\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other],\n * i.e. both char sequences contain the same number of the same characters in the same order.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic actual infix fun CharSequence?.contentEquals(other: CharSequence?): Boolean = contentEqualsImpl(other)\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other], optionally ignoring case difference.\n *\n * @param ignoreCase `true` to ignore character case when comparing contents.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic actual fun CharSequence?.contentEquals(other: CharSequence?, ignoreCase: Boolean): Boolean {\n    return if (ignoreCase)\n        this.contentEqualsIgnoreCaseImpl(other)\n    else\n        this.contentEqualsImpl(other)\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireNotNullWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\nimport kotlin.contracts.*\nimport kotlin.jvm.JvmInline\nimport kotlin.math.*\n\n/**\n * Represents the amount of time one instant of time is away from another instant.\n *\n * A negative duration is possible in a situation when the second instant is earlier than the first one.\n * An infinite duration value [Duration.INFINITE] can be used to represent infinite timeouts.\n *\n * The type can store duration values up to \u00b1146 years with nanosecond precision,\n * and up to \u00b1146 million years with millisecond precision.\n *\n * To construct a duration, use either the extension function [toDuration] available on [Int], [Long], and [Double] numeric types,\n * or the `Duration` companion object functions [Duration.hours], [Duration.minutes], [Duration.seconds], and so on,\n * taking [Int], [Long], or [Double] numbers as parameters.\n *\n * To get the value of this duration expressed in a particular [duration units][DurationUnit]\n * use the functions [toInt], [toLong], and [toDouble]\n * or the properties [inWholeHours], [inWholeMinutes], [inWholeSeconds], [inWholeNanoseconds], and so on.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@JvmInline\npublic value class Duration internal constructor(private val rawValue: Long) : Comparable<Duration> {\n\n    private val value: Long get() = rawValue shr 1\n    private inline val unitDiscriminator: Int get() = rawValue.toInt() and 1\n    private fun isInNanos() = unitDiscriminator == 0\n    private fun isInMillis() = unitDiscriminator == 1\n    private val storageUnit get() = if (isInNanos()) DurationUnit.NANOSECONDS else DurationUnit.MILLISECONDS\n\n    init {\n        // TODO: disable assertions in final version\n        if (isInNanos()) {\n            if (value !in -MAX_NANOS..MAX_NANOS) throw AssertionError(\"$value ns is out of nanoseconds range\")\n        } else {\n            if (value !in -MAX_MILLIS..MAX_MILLIS) throw AssertionError(\"$value ms is out of milliseconds range\")\n            if (value in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) throw AssertionError(\"$value ms is denormalized\")\n        }\n    }\n\n    companion object {\n        /** The duration equal to exactly 0 seconds. */\n        public val ZERO: Duration = Duration(0L)\n\n        /** The duration whose value is positive infinity. It is useful for representing timeouts that should never expire. */\n        public val INFINITE: Duration = durationOfMillis(MAX_MILLIS)\n        internal val NEG_INFINITE: Duration = durationOfMillis(-MAX_MILLIS)\n\n        /** Converts the given time duration [value] expressed in the specified [sourceUnit] into the specified [targetUnit]. */\n        public fun convert(value: Double, sourceUnit: DurationUnit, targetUnit: DurationUnit): Double =\n            convertDurationUnit(value, sourceUnit, targetUnit)\n\n        /** Returns a [Duration] representing the specified [value] number of nanoseconds. */\n        @SinceKotlin(\"1.5\")\n        public fun nanoseconds(value: Int): Duration = value.toDuration(DurationUnit.NANOSECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of nanoseconds. */\n        @SinceKotlin(\"1.5\")\n        public fun nanoseconds(value: Long): Duration = value.toDuration(DurationUnit.NANOSECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of nanoseconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun nanoseconds(value: Double): Duration = value.toDuration(DurationUnit.NANOSECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of microseconds. */\n        @SinceKotlin(\"1.5\")\n        public fun microseconds(value: Int): Duration = value.toDuration(DurationUnit.MICROSECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of microseconds. */\n        @SinceKotlin(\"1.5\")\n        public fun microseconds(value: Long): Duration = value.toDuration(DurationUnit.MICROSECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of microseconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun microseconds(value: Double): Duration = value.toDuration(DurationUnit.MICROSECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of milliseconds. */\n        @SinceKotlin(\"1.5\")\n        public fun milliseconds(value: Int): Duration = value.toDuration(DurationUnit.MILLISECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of milliseconds. */\n        @SinceKotlin(\"1.5\")\n        public fun milliseconds(value: Long): Duration = value.toDuration(DurationUnit.MILLISECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of milliseconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun milliseconds(value: Double): Duration = value.toDuration(DurationUnit.MILLISECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of seconds. */\n        @SinceKotlin(\"1.5\")\n        public fun seconds(value: Int): Duration = value.toDuration(DurationUnit.SECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of seconds. */\n        @SinceKotlin(\"1.5\")\n        public fun seconds(value: Long): Duration = value.toDuration(DurationUnit.SECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of seconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun seconds(value: Double): Duration = value.toDuration(DurationUnit.SECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of minutes. */\n        @SinceKotlin(\"1.5\")\n        public fun minutes(value: Int): Duration = value.toDuration(DurationUnit.MINUTES)\n\n        /** Returns a [Duration] representing the specified [value] number of minutes. */\n        @SinceKotlin(\"1.5\")\n        public fun minutes(value: Long): Duration = value.toDuration(DurationUnit.MINUTES)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of minutes.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun minutes(value: Double): Duration = value.toDuration(DurationUnit.MINUTES)\n\n        /** Returns a [Duration] representing the specified [value] number of hours. */\n        @SinceKotlin(\"1.5\")\n        public fun hours(value: Int): Duration = value.toDuration(DurationUnit.HOURS)\n\n        /** Returns a [Duration] representing the specified [value] number of hours. */\n        @SinceKotlin(\"1.5\")\n        public fun hours(value: Long): Duration = value.toDuration(DurationUnit.HOURS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of hours.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun hours(value: Double): Duration = value.toDuration(DurationUnit.HOURS)\n\n        /** Returns a [Duration] representing the specified [value] number of days. */\n        @SinceKotlin(\"1.5\")\n        public fun days(value: Int): Duration = value.toDuration(DurationUnit.DAYS)\n\n        /** Returns a [Duration] representing the specified [value] number of days. */\n        @SinceKotlin(\"1.5\")\n        public fun days(value: Long): Duration = value.toDuration(DurationUnit.DAYS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of days.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun days(value: Double): Duration = value.toDuration(DurationUnit.DAYS)\n\n        /**\n         * Parses a string that represents a duration and returns the parsed [Duration] value.\n         *\n         * The following formats are accepted:\n         *\n         * - ISO-8601 Duration format, e.g. `P1DT2H3M4.058S`, see [toIsoString] and [parseIsoString].\n         * - The format of string returned by the default [Duration.toString] and `toString` in a specific unit,\n         *   e.g. `10s`, `1h 30m` or `-(1h 30m)`.\n         *\n         * @throws IllegalArgumentException if the string doesn't represent a duration in any of the supported formats.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun parse(value: String): Duration = try {\n            parseDuration(value, strictIso = false)\n        } catch (e: IllegalArgumentException) {\n            throw IllegalArgumentException(\"Invalid duration string format: '$value'.\", e)\n        }\n\n        /**\n         * Parses a string that represents a duration in ISO-8601 format and returns the parsed [Duration] value.\n         *\n         * @throws IllegalArgumentException if the string doesn't represent a duration in ISO-8601 format.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun parseIsoString(value: String): Duration = try {\n            parseDuration(value, strictIso = true)\n        } catch (e: IllegalArgumentException) {\n            throw IllegalArgumentException(\"Invalid ISO duration string format: '$value'.\", e)\n        }\n\n        /**\n         * Parses a string that represents a duration and returns the parsed [Duration] value,\n         * or `null` if the string doesn't represent a duration in any of the supported formats.\n         *\n         * The following formats are accepted:\n         *\n         * - ISO-8601 Duration format, e.g. `P1DT2H3M4.058S`, see [toIsoString] and [parseIsoString].\n         * - The format of string returned by the default [Duration.toString] and `toString` in a specific unit,\n         *   e.g. `10s`, `1h 30m` or `-(1h 30m)`.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun parseOrNull(value: String): Duration? = try {\n            parseDuration(value, strictIso = false)\n        } catch (e: IllegalArgumentException) {\n            null\n        }\n\n        /**\n         * Parses a string that represents a duration in ISO-8601 format and returns the parsed [Duration] value,\n         * or `null` if the string doesn't represent a duration in ISO-8601 format.\n         */\n        @SinceKotlin(\"1.5\")\n        public fun parseIsoStringOrNull(value: String): Duration? = try {\n            parseDuration(value, strictIso = true)\n        } catch (e: IllegalArgumentException) {\n            null\n        }\n    }\n\n    // arithmetic operators\n\n    /** Returns the negative of this value. */\n    public operator fun unaryMinus(): Duration = durationOf(-value, unitDiscriminator)\n\n    /**\n     * Returns a duration whose value is the sum of this and [other] duration values.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when adding infinite durations of different sign.\n     */\n    public operator fun plus(other: Duration): Duration {\n        when {\n            this.isInfinite() -> {\n                if (other.isFinite() || (this.rawValue xor other.rawValue >= 0))\n                    return this\n                else\n                    throw IllegalArgumentException(\"Summing infinite durations of different signs yields an undefined result.\")\n            }\n            other.isInfinite() -> return other\n        }\n\n        return when {\n            this.unitDiscriminator == other.unitDiscriminator -> {\n                val result = this.value + other.value // never overflows long, but can overflow long63\n                when {\n                    isInNanos() ->\n                        durationOfNanosNormalized(result)\n                    else ->\n                        durationOfMillisNormalized(result)\n                }\n            }\n            this.isInMillis() ->\n                addValuesMixedRanges(this.value, other.value)\n            else ->\n                addValuesMixedRanges(other.value, this.value)\n        }\n    }\n\n    private fun addValuesMixedRanges(thisMillis: Long, otherNanos: Long): Duration {\n        val otherMillis = nanosToMillis(otherNanos)\n        val resultMillis = thisMillis + otherMillis\n        return if (resultMillis in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) {\n            val otherNanoRemainder = otherNanos - millisToNanos(otherMillis)\n            durationOfNanos(millisToNanos(resultMillis) + otherNanoRemainder)\n        } else {\n            durationOfMillis(resultMillis.coerceIn(-MAX_MILLIS, MAX_MILLIS))\n        }\n    }\n\n    /**\n     * Returns a duration whose value is the difference between this and [other] duration values.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when subtracting infinite durations of the same sign.\n     */\n    public operator fun minus(other: Duration): Duration = this + (-other)\n\n    /**\n     * Returns a duration whose value is this duration value multiplied by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when multiplying an infinite duration by zero.\n     */\n    public operator fun times(scale: Int): Duration {\n        if (isInfinite()) {\n            return when {\n                scale == 0 -> throw IllegalArgumentException(\"Multiplying infinite duration by zero yields an undefined result.\")\n                scale > 0 -> this\n                else -> -this\n            }\n        }\n        if (scale == 0) return ZERO\n\n        val value = value\n        val result = value * scale\n        return if (isInNanos()) {\n            if (value in (MAX_NANOS / Int.MIN_VALUE)..(-MAX_NANOS / Int.MIN_VALUE)) {\n                // can't overflow nanos range for any scale\n                durationOfNanos(result)\n            } else {\n                if (result / scale == value) {\n                    durationOfNanosNormalized(result)\n                } else {\n                    val millis = nanosToMillis(value)\n                    val remNanos = value - millisToNanos(millis)\n                    val resultMillis = millis * scale\n                    val totalMillis = resultMillis + nanosToMillis(remNanos * scale)\n                    if (resultMillis / scale == millis && totalMillis xor resultMillis >= 0) {\n                        durationOfMillis(totalMillis.coerceIn(-MAX_MILLIS..MAX_MILLIS))\n                    } else {\n                        if (value.sign * scale.sign > 0) INFINITE else NEG_INFINITE\n                    }\n                }\n            }\n        } else {\n            if (result / scale == value) {\n                durationOfMillis(result.coerceIn(-MAX_MILLIS..MAX_MILLIS))\n            } else {\n                if (value.sign * scale.sign > 0) INFINITE else NEG_INFINITE\n            }\n        }\n    }\n\n    /**\n     * Returns a duration whose value is this duration value multiplied by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when multiplying an infinite duration by zero.\n     */\n    public operator fun times(scale: Double): Duration {\n        val intScale = scale.roundToInt()\n        if (intScale.toDouble() == scale) {\n            return times(intScale)\n        }\n\n        val unit = storageUnit\n        val result = toDouble(unit) * scale\n        return result.toDuration(unit)\n    }\n\n    /**\n     * Returns a duration whose value is this duration value divided by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when dividing zero duration by zero.\n     */\n    public operator fun div(scale: Int): Duration {\n        if (scale == 0) {\n            return when {\n                isPositive() -> INFINITE\n                isNegative() -> NEG_INFINITE\n                else -> throw IllegalArgumentException(\"Dividing zero duration by zero yields an undefined result.\")\n            }\n        }\n        if (isInNanos()) {\n            return durationOfNanos(value / scale)\n        } else {\n            if (isInfinite())\n                return this * scale.sign\n\n            val result = value / scale\n\n            if (result in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) {\n                val rem = millisToNanos(value - (result * scale)) / scale\n                return durationOfNanos(millisToNanos(result) + rem)\n            }\n            return durationOfMillis(result)\n        }\n    }\n\n    /**\n     * Returns a duration whose value is this duration value divided by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when dividing an infinite duration by infinity or zero duration by zero.\n     */\n    public operator fun div(scale: Double): Duration {\n        val intScale = scale.roundToInt()\n        if (intScale.toDouble() == scale && intScale != 0) {\n            return div(intScale)\n        }\n\n        val unit = storageUnit\n        val result = toDouble(unit) / scale\n        return result.toDuration(unit)\n    }\n\n    /** Returns a number that is the ratio of this and [other] duration values. */\n    public operator fun div(other: Duration): Double {\n        val coarserUnit = maxOf(this.storageUnit, other.storageUnit)\n        return this.toDouble(coarserUnit) / other.toDouble(coarserUnit)\n    }\n\n    /** Returns true, if the duration value is less than zero. */\n    public fun isNegative(): Boolean = rawValue < 0\n\n    /** Returns true, if the duration value is greater than zero. */\n    public fun isPositive(): Boolean = rawValue > 0\n\n    /** Returns true, if the duration value is infinite. */\n    public fun isInfinite(): Boolean = rawValue == INFINITE.rawValue || rawValue == NEG_INFINITE.rawValue\n\n    /** Returns true, if the duration value is finite. */\n    public fun isFinite(): Boolean = !isInfinite()\n\n    /** Returns the absolute value of this value. The returned value is always non-negative. */\n    public val absoluteValue: Duration get() = if (isNegative()) -this else this\n\n    override fun compareTo(other: Duration): Int {\n        val compareBits = this.rawValue xor other.rawValue\n        if (compareBits < 0 || compareBits.toInt() and 1 == 0) // different signs or same sign/same range\n            return this.rawValue.compareTo(other.rawValue)\n        // same sign/different ranges\n        val r = this.unitDiscriminator - other.unitDiscriminator // compare ranges\n        return if (isNegative()) -r else r\n    }\n\n\n    // splitting to components\n\n    /**\n     * Splits this duration into days, hours, minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration, and its absolute value is less than 60;\n     * - `hours` represents the whole number of hours in this duration, and its absolute value is less than 24;\n     * - `days` represents the whole number of days in this duration.\n     *   If the value doesn't fit in [Int] range, i.e. it's greater than [Int.MAX_VALUE] or less than [Int.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (days: Int, hours: Int, minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(toInt(DurationUnit.DAYS), hoursComponent, minutesComponent, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into hours, minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration, and its absolute value is less than 60;\n     * - `hours` represents the whole number of hours in this duration.\n     *   If the value doesn't fit in [Int] range, i.e. it's greater than [Int.MAX_VALUE] or less than [Int.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (hours: Int, minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(toInt(DurationUnit.HOURS), minutesComponent, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration.\n     *   If the value doesn't fit in [Int] range, i.e. it's greater than [Int.MAX_VALUE] or less than [Int.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(toInt(DurationUnit.MINUTES), secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration.\n     *   If the value doesn't fit in [Long] range, i.e. it's greater than [Long.MAX_VALUE] or less than [Long.MIN_VALUE],\n     *   it is coerced into that range.\n     */\n    public inline fun <T> toComponents(action: (seconds: Long, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inWholeSeconds, nanosecondsComponent)\n    }\n\n    @PublishedApi\n    internal val hoursComponent: Int\n        get() = if (isInfinite()) 0 else (inWholeHours % 24).toInt()\n\n    @PublishedApi\n    internal val minutesComponent: Int\n        get() = if (isInfinite()) 0 else (inWholeMinutes % 60).toInt()\n\n    @PublishedApi\n    internal val secondsComponent: Int\n        get() = if (isInfinite()) 0 else (inWholeSeconds % 60).toInt()\n\n    @PublishedApi\n    internal val nanosecondsComponent: Int\n        get() = when {\n            isInfinite() -> 0\n            isInMillis() -> millisToNanos(value % 1_000).toInt()\n            else -> (value % 1_000_000_000).toInt()\n        }\n\n\n    // conversion to units\n\n    /**\n     * Returns the value of this duration expressed as a [Double] number of the specified [unit].\n     *\n     * An infinite duration value is converted either to [Double.POSITIVE_INFINITY] or [Double.NEGATIVE_INFINITY] depending on its sign.\n     */\n    public fun toDouble(unit: DurationUnit): Double {\n        return when (rawValue) {\n            INFINITE.rawValue -> Double.POSITIVE_INFINITY\n            NEG_INFINITE.rawValue -> Double.NEGATIVE_INFINITY\n            else -> {\n                // TODO: whether it's ok to convert to Double before scaling\n                convertDurationUnit(value.toDouble(), storageUnit, unit)\n            }\n        }\n    }\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of the specified [unit].\n     *\n     * If the result doesn't fit in the range of [Long] type, it is coerced into that range:\n     * - [Long.MIN_VALUE] is returned if it's less than `Long.MIN_VALUE`,\n     * - [Long.MAX_VALUE] is returned if it's greater than `Long.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public fun toLong(unit: DurationUnit): Long {\n        return when (rawValue) {\n            INFINITE.rawValue -> Long.MAX_VALUE\n            NEG_INFINITE.rawValue -> Long.MIN_VALUE\n            else -> convertDurationUnit(value, storageUnit, unit)\n        }\n    }\n\n    /**\n     * Returns the value of this duration expressed as an [Int] number of the specified [unit].\n     *\n     * If the result doesn't fit in the range of [Int] type, it is coerced into that range:\n     * - [Int.MIN_VALUE] is returned if it's less than `Int.MIN_VALUE`,\n     * - [Int.MAX_VALUE] is returned if it's greater than `Int.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Int.MAX_VALUE] or [Int.MIN_VALUE] depending on its sign.\n     */\n    public fun toInt(unit: DurationUnit): Int =\n        toLong(unit).coerceIn(Int.MIN_VALUE.toLong(), Int.MAX_VALUE.toLong()).toInt()\n\n    /** The value of this duration expressed as a [Double] number of days. */\n    @Deprecated(\"Use inWholeDays property instead or convert toDouble(DAYS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.DAYS)\"))\n    public val inDays: Double get() = toDouble(DurationUnit.DAYS)\n\n    /** The value of this duration expressed as a [Double] number of hours. */\n    @Deprecated(\"Use inWholeHours property instead or convert toDouble(HOURS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.HOURS)\"))\n    public val inHours: Double get() = toDouble(DurationUnit.HOURS)\n\n    /** The value of this duration expressed as a [Double] number of minutes. */\n    @Deprecated(\"Use inWholeMinutes property instead or convert toDouble(MINUTES) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.MINUTES)\"))\n    public val inMinutes: Double get() = toDouble(DurationUnit.MINUTES)\n\n    /** The value of this duration expressed as a [Double] number of seconds. */\n    @Deprecated(\"Use inWholeSeconds property instead or convert toDouble(SECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.SECONDS)\"))\n    public val inSeconds: Double get() = toDouble(DurationUnit.SECONDS)\n\n    /** The value of this duration expressed as a [Double] number of milliseconds. */\n    @Deprecated(\"Use inWholeMilliseconds property instead or convert toDouble(MILLISECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.MILLISECONDS)\"))\n    public val inMilliseconds: Double get() = toDouble(DurationUnit.MILLISECONDS)\n\n    /** The value of this duration expressed as a [Double] number of microseconds. */\n    @Deprecated(\"Use inWholeMicroseconds property instead or convert toDouble(MICROSECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.MICROSECONDS)\"))\n    public val inMicroseconds: Double get() = toDouble(DurationUnit.MICROSECONDS)\n\n    /** The value of this duration expressed as a [Double] number of nanoseconds. */\n    @Deprecated(\"Use inWholeNanoseconds property instead or convert toDouble(NANOSECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.NANOSECONDS)\"))\n    public val inNanoseconds: Double get() = toDouble(DurationUnit.NANOSECONDS)\n\n\n    /**\n     * The value of this duration expressed as a [Long] number of days.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeDays: Long\n        get() = toLong(DurationUnit.DAYS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of hours.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeHours: Long\n        get() = toLong(DurationUnit.HOURS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of minutes.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeMinutes: Long\n        get() = toLong(DurationUnit.MINUTES)\n\n    /**\n     * The value of this duration expressed as a [Long] number of seconds.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeSeconds: Long\n        get() = toLong(DurationUnit.SECONDS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of milliseconds.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeMilliseconds: Long\n        get() {\n            return if (isInMillis() && isFinite()) value else toLong(DurationUnit.MILLISECONDS)\n        }\n\n    /**\n     * The value of this duration expressed as a [Long] number of microseconds.\n     *\n     * If the result doesn't fit in the range of [Long] type, it is coerced into that range:\n     * - [Long.MIN_VALUE] is returned if it's less than `Long.MIN_VALUE`,\n     * - [Long.MAX_VALUE] is returned if it's greater than `Long.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeMicroseconds: Long\n        get() = toLong(DurationUnit.MICROSECONDS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of nanoseconds.\n     *\n     * If the result doesn't fit in the range of [Long] type, it is coerced into that range:\n     * - [Long.MIN_VALUE] is returned if it's less than `Long.MIN_VALUE`,\n     * - [Long.MAX_VALUE] is returned if it's greater than `Long.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    @SinceKotlin(\"1.5\")\n    public val inWholeNanoseconds: Long\n        get() {\n            val value = value\n            return when {\n                isInNanos() -> value\n                value > Long.MAX_VALUE / NANOS_IN_MILLIS -> Long.MAX_VALUE\n                value < Long.MIN_VALUE / NANOS_IN_MILLIS -> Long.MIN_VALUE\n                else -> millisToNanos(value)\n            }\n        }\n\n    // shortcuts\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of nanoseconds.\n     *\n     * If the value doesn't fit in the range of [Long] type, it is coerced into that range, see the conversion [Double.toLong] for details.\n     *\n     * The range of durations that can be expressed as a `Long` number of nanoseconds is approximately \u00b1292 years.\n     */\n    @Deprecated(\"Use inWholeNanoseconds property instead.\", ReplaceWith(\"this.inWholeNanoseconds\"))\n    public fun toLongNanoseconds(): Long = inWholeNanoseconds\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of milliseconds.\n     *\n     * The value is coerced to the range of [Long] type, if it doesn't fit in that range, see the conversion [Double.toLong] for details.\n     *\n     * The range of durations that can be expressed as a `Long` number of milliseconds is approximately \u00b1292 million years.\n     */\n    @Deprecated(\"Use inWholeMilliseconds property instead.\", ReplaceWith(\"this.inWholeMilliseconds\"))\n    public fun toLongMilliseconds(): Long = inWholeMilliseconds\n\n    /**\n     * Returns a string representation of this duration value\n     * expressed as a combination of numeric components, each in its own unit.\n     *\n     * Each component is a number followed by the unit abbreviated name: `d`, `h`, `m`, `s`:\n     * `5h`, `1d 12h`, `1h 0m 30.3340s`.\n     * The last component, usually seconds, can be a number with a fractional part.\n     *\n     * If the duration is less than a second, it is represented as a single number\n     * with one of sub-second units: `ms` (milliseconds), `us` (microseconds), or `ns` (nanoseconds):\n     * `140.884ms`, `500us`, `24ns`.\n     *\n     * A negative duration is prefixed with `-` sign and, if it consists of multiple components, surrounded with parentheses:\n     * `-12m` and `-(1h 30m)`.\n     *\n     * Special cases:\n     *  - an infinite duration is formatted as `\"Infinity\"` or `\"-Infinity\"` without a unit.\n     *\n     * It's recommended to use [toIsoString] that uses more strict ISO-8601 format instead of this `toString`\n     * when you want to convert a duration to a string in cases of serialization, interchange, etc.\n     *\n     * @sample samples.time.Durations.toStringDefault\n     */\n    override fun toString(): String = when (rawValue) {\n        0L -> \"0s\"\n        INFINITE.rawValue -> \"Infinity\"\n        NEG_INFINITE.rawValue -> \"-Infinity\"\n        else -> {\n            val isNegative = isNegative()\n            buildString {\n                if (isNegative) append('-')\n                absoluteValue.run {\n                    toComponents { _, hours, minutes, seconds, nanoseconds ->\n                        val days = inWholeDays\n                        val hasDays = days != 0L\n                        val hasHours = hours != 0\n                        val hasMinutes = minutes != 0\n                        val hasSeconds = seconds != 0 || nanoseconds != 0\n                        var components = 0\n                        if (hasDays) {\n                            append(days).append('d')\n                            components++\n                        }\n                        if (hasHours || (hasDays && (hasMinutes || hasSeconds))) {\n                            if (components++ > 0) append(' ')\n                            append(hours).append('h')\n                        }\n                        if (hasMinutes || (hasSeconds && (hasHours || hasDays))) {\n                            if (components++ > 0) append(' ')\n                            append(minutes).append('m')\n                        }\n                        if (hasSeconds) {\n                            if (components++ > 0) append(' ')\n                            when {\n                                seconds != 0 || hasDays || hasHours || hasMinutes ->\n                                    appendFractional(seconds, nanoseconds, 9, \"s\", isoZeroes = false)\n                                nanoseconds >= 1_000_000 ->\n                                    appendFractional(nanoseconds / 1_000_000, nanoseconds % 1_000_000, 6, \"ms\", isoZeroes = false)\n                                nanoseconds >= 1_000 ->\n                                    appendFractional(nanoseconds / 1_000, nanoseconds % 1_000, 3, \"us\", isoZeroes = false)\n                                else ->\n                                    append(nanoseconds).append(\"ns\")\n                            }\n                        }\n                        if (isNegative && components > 1) insert(1, '(').append(')')\n                    }\n                }\n            }\n        }\n    }\n\n    private fun StringBuilder.appendFractional(whole: Int, fractional: Int, fractionalSize: Int, unit: String, isoZeroes: Boolean) {\n        append(whole)\n        if (fractional != 0) {\n            append('.')\n            val fracString = fractional.toString().padStart(fractionalSize, '0')\n            val nonZeroDigits = fracString.indexOfLast { it != '0' } + 1\n            when {\n                !isoZeroes && nonZeroDigits < 3 -> appendRange(fracString, 0, nonZeroDigits)\n                else -> appendRange(fracString, 0, ((nonZeroDigits + 2) / 3) * 3)\n            }\n        }\n        append(unit)\n    }\n\n    /**\n     * Returns a string representation of this duration value expressed in the given [unit]\n     * and formatted with the specified [decimals] number of digits after decimal point.\n     *\n     * Special cases:\n     *  - an infinite duration is formatted as `\"Infinity\"` or `\"-Infinity\"` without a unit.\n     *\n     * @param decimals the number of digits after decimal point to show. The value must be non-negative.\n     * No more than 12 decimals will be shown, even if a larger number is requested.\n     *\n     * @return the value of duration in the specified [unit] followed by that unit abbreviated name: `d`, `h`, `m`, `s`, `ms`, `us`, or `ns`.\n     *\n     * @throws IllegalArgumentException if [decimals] is less than zero.\n     *\n     * @sample samples.time.Durations.toStringDecimals\n     */\n    public fun toString(unit: DurationUnit, decimals: Int = 0): String {\n        require(decimals >= 0) { \"decimals must be not negative, but was $decimals\" }\n        val number = toDouble(unit)\n        if (number.isInfinite()) return number.toString()\n        return formatToExactDecimals(number, decimals.coerceAtMost(12)) + unit.shortName()\n    }\n\n\n    /**\n     * Returns an ISO-8601 based string representation of this duration.\n     *\n     * The returned value is presented in the format `PThHmMs.fS`, where `h`, `m`, `s` are the integer components of this duration (see [toComponents])\n     * and `f` is a fractional part of second. Depending on the roundness of the value the fractional part can be formatted with either\n     * 0, 3, 6, or 9 decimal digits.\n     *\n     * If the hours component absolute value of this duration is greater than [Int.MAX_VALUE], it is replaced with [Int.MAX_VALUE],\n     * so the infinite duration is formatted as `\"PT2147483647H\".\n     *\n     * Negative durations are indicated with the sign `-` in the beginning of the returned string, for example, `\"-PT5M30S\"`.\n     *\n     * @sample samples.time.Durations.toIsoString\n     */\n    public fun toIsoString(): String = buildString {\n        if (isNegative()) append('-')\n        append(\"PT\")\n        val absoluteValue = this@Duration.absoluteValue\n        absoluteValue.toComponents { _, minutes, seconds, nanoseconds ->\n            var hours = absoluteValue.inWholeHours\n            if (isInfinite()) {\n                // use large enough value instead of Long.MAX_VALUE\n                hours = 9_999_999_999_999\n            }\n            val hasHours = hours != 0L\n            val hasSeconds = seconds != 0 || nanoseconds != 0\n            val hasMinutes = minutes != 0 || (hasSeconds && hasHours)\n            if (hasHours) {\n                append(hours).append('H')\n            }\n            if (hasMinutes) {\n                append(minutes).append('M')\n            }\n            if (hasSeconds || (!hasHours && !hasMinutes)) {\n                appendFractional(seconds, nanoseconds, 9, \"S\", isoZeroes = true)\n            }\n        }\n    }\n\n}\n\n// constructing from number of units\n// extension functions\n\n/** Returns a [Duration] equal to this [Int] number of the specified [unit]. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic fun Int.toDuration(unit: DurationUnit): Duration {\n    return if (unit <= DurationUnit.SECONDS) {\n        durationOfNanos(convertDurationUnitOverflow(this.toLong(), unit, DurationUnit.NANOSECONDS))\n    } else\n        toLong().toDuration(unit)\n}\n\n/** Returns a [Duration] equal to this [Long] number of the specified [unit]. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic fun Long.toDuration(unit: DurationUnit): Duration {\n    val maxNsInUnit = convertDurationUnitOverflow(MAX_NANOS, DurationUnit.NANOSECONDS, unit)\n    if (this in -maxNsInUnit..maxNsInUnit) {\n        return durationOfNanos(convertDurationUnitOverflow(this, unit, DurationUnit.NANOSECONDS))\n    } else {\n        val millis = convertDurationUnit(this, unit, DurationUnit.MILLISECONDS)\n        return durationOfMillis(millis.coerceIn(-MAX_MILLIS, MAX_MILLIS))\n    }\n}\n\n/**\n * Returns a [Duration] equal to this [Double] number of the specified [unit].\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\npublic fun Double.toDuration(unit: DurationUnit): Duration {\n    val valueInNs = convertDurationUnit(this, unit, DurationUnit.NANOSECONDS)\n    require(!valueInNs.isNaN()) { \"Duration value cannot be NaN.\" }\n    val nanos = valueInNs.roundToLong()\n    return if (nanos in -MAX_NANOS..MAX_NANOS) {\n        durationOfNanos(nanos)\n    } else {\n        val millis = convertDurationUnit(this, unit, DurationUnit.MILLISECONDS).roundToLong()\n        durationOfMillisNormalized(millis)\n    }\n}\n\n// constructing from number of units\n// extension properties\n\n/** Returns a [Duration] equal to this [Int] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.nanoseconds() function instead.\", ReplaceWith(\"Duration.nanoseconds(this)\", \"kotlin.time.Duration\"))\npublic val Int.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.nanoseconds() function instead.\", ReplaceWith(\"Duration.nanoseconds(this)\", \"kotlin.time.Duration\"))\npublic val Long.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of nanoseconds.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.nanoseconds() function instead.\", ReplaceWith(\"Duration.nanoseconds(this)\", \"kotlin.time.Duration\"))\npublic val Double.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.microseconds() function instead.\", ReplaceWith(\"Duration.microseconds(this)\", \"kotlin.time.Duration\"))\npublic val Int.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.microseconds() function instead.\", ReplaceWith(\"Duration.microseconds(this)\", \"kotlin.time.Duration\"))\npublic val Long.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of microseconds.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.microseconds() function instead.\", ReplaceWith(\"Duration.microseconds(this)\", \"kotlin.time.Duration\"))\npublic val Double.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.milliseconds() function instead.\", ReplaceWith(\"Duration.milliseconds(this)\", \"kotlin.time.Duration\"))\npublic val Int.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.milliseconds() function instead.\", ReplaceWith(\"Duration.milliseconds(this)\", \"kotlin.time.Duration\"))\npublic val Long.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of milliseconds.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.milliseconds() function instead.\", ReplaceWith(\"Duration.milliseconds(this)\", \"kotlin.time.Duration\"))\npublic val Double.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.seconds() function instead.\", ReplaceWith(\"Duration.seconds(this)\", \"kotlin.time.Duration\"))\npublic val Int.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.seconds() function instead.\", ReplaceWith(\"Duration.seconds(this)\", \"kotlin.time.Duration\"))\npublic val Long.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of seconds.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.seconds() function instead.\", ReplaceWith(\"Duration.seconds(this)\", \"kotlin.time.Duration\"))\npublic val Double.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/** Returns a [Duration] equal to this [Int] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.minutes() function instead.\", ReplaceWith(\"Duration.minutes(this)\", \"kotlin.time.Duration\"))\npublic val Int.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/** Returns a [Duration] equal to this [Long] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.minutes() function instead.\", ReplaceWith(\"Duration.minutes(this)\", \"kotlin.time.Duration\"))\npublic val Long.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/**\n * Returns a [Duration] equal to this [Double] number of minutes.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.minutes() function instead.\", ReplaceWith(\"Duration.minutes(this)\", \"kotlin.time.Duration\"))\npublic val Double.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/** Returns a [Duration] equal to this [Int] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.hours() function instead.\", ReplaceWith(\"Duration.hours(this)\", \"kotlin.time.Duration\"))\npublic val Int.hours get() = toDuration(DurationUnit.HOURS)\n\n/** Returns a [Duration] equal to this [Long] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.hours() function instead.\", ReplaceWith(\"Duration.hours(this)\", \"kotlin.time.Duration\"))\npublic val Long.hours get() = toDuration(DurationUnit.HOURS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of hours.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.hours() function instead.\", ReplaceWith(\"Duration.hours(this)\", \"kotlin.time.Duration\"))\npublic val Double.hours get() = toDuration(DurationUnit.HOURS)\n\n/** Returns a [Duration] equal to this [Int] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.days() function instead.\", ReplaceWith(\"Duration.days(this)\", \"kotlin.time.Duration\"))\npublic val Int.days get() = toDuration(DurationUnit.DAYS)\n\n/** Returns a [Duration] equal to this [Long] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.days() function instead.\", ReplaceWith(\"Duration.days(this)\", \"kotlin.time.Duration\"))\npublic val Long.days get() = toDuration(DurationUnit.DAYS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of days.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use Duration.days() function instead.\", ReplaceWith(\"Duration.days(this)\", \"kotlin.time.Duration\"))\npublic val Double.days get() = toDuration(DurationUnit.DAYS)\n\n\n/** Returns a duration whose value is the specified [duration] value multiplied by this number. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@kotlin.internal.InlineOnly\npublic inline operator fun Int.times(duration: Duration): Duration = duration * this\n\n/**\n * Returns a duration whose value is the specified [duration] value multiplied by this number.\n *\n * @throws IllegalArgumentException if the operation results in a `NaN` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@kotlin.internal.InlineOnly\npublic inline operator fun Double.times(duration: Duration): Duration = duration * this\n\n\n\n@ExperimentalTime\nprivate fun parseDuration(value: String, strictIso: Boolean): Duration {\n    var length = value.length\n    if (length == 0) throw IllegalArgumentException(\"The string is empty\")\n    var index = 0\n    var result = Duration.ZERO\n    val infinityString = \"Infinity\"\n    when (value[index]) {\n        '+', '-' -> index++\n    }\n    val hasSign = index > 0\n    val isNegative = hasSign && value.startsWith('-')\n    when {\n        length <= index ->\n            throw IllegalArgumentException(\"No components\")\n        value[index] == 'P' -> {\n            if (++index == length) throw IllegalArgumentException()\n            val nonDigitSymbols = \"+-.\"\n            var isTimeComponent = false\n            var prevUnit: DurationUnit? = null\n            while (index < length) {\n                if (value[index] == 'T') {\n                    if (isTimeComponent || ++index == length) throw IllegalArgumentException()\n                    isTimeComponent = true\n                    continue\n                }\n                val component = value.substringWhile(index) { it in '0'..'9' || it in nonDigitSymbols }\n                if (component.isEmpty()) throw IllegalArgumentException()\n                index += component.length\n                val unitChar = value.getOrElse(index) { throw IllegalArgumentException(\"Missing unit for value $component\") }\n                index++\n                val unit = durationUnitByIsoChar(unitChar, isTimeComponent)\n                if (prevUnit != null && prevUnit <= unit) throw IllegalArgumentException(\"Unexpected order of duration components\")\n                prevUnit = unit\n                val dotIndex = component.indexOf('.')\n                if (unit == DurationUnit.SECONDS && dotIndex > 0) {\n                    val whole = component.substring(0, dotIndex)\n                    result += parseOverLongIsoComponent(whole).toDuration(unit)\n                    result += component.substring(dotIndex).toDouble().toDuration(unit)\n                } else {\n                    result += parseOverLongIsoComponent(component).toDuration(unit)\n                }\n            }\n        }\n        strictIso ->\n            throw IllegalArgumentException()\n        value.regionMatches(index, infinityString, 0, length = maxOf(length - index, infinityString.length), ignoreCase = true) -> {\n            result = Duration.INFINITE\n        }\n        else -> {\n            // parse default string format\n            var prevUnit: DurationUnit? = null\n            var afterFirst = false\n            var allowSpaces = !hasSign\n            if (hasSign && value[index] == '(' && value.last() == ')') {\n                allowSpaces = true\n                if (++index == --length) throw IllegalArgumentException(\"No components\")\n            }\n            while (index < length) {\n                if (afterFirst && allowSpaces) {\n                    index = value.skipWhile(index) { it == ' ' }\n                }\n                afterFirst = true\n                val component = value.substringWhile(index) { it in '0'..'9' || it == '.' }\n                if (component.isEmpty()) throw IllegalArgumentException()\n                index += component.length\n                val unitName = value.substringWhile(index) { it in 'a'..'z' }\n                index += unitName.length\n                val unit = durationUnitByShortName(unitName)\n                if (prevUnit != null && prevUnit <= unit) throw IllegalArgumentException(\"Unexpected order of duration components\")\n                prevUnit = unit\n                val dotIndex = component.indexOf('.')\n                if (dotIndex > 0) {\n                    val whole = component.substring(0, dotIndex)\n                    result += whole.toLong().toDuration(unit)\n                    result += component.substring(dotIndex).toDouble().toDuration(unit)\n                    if (index < length) throw IllegalArgumentException(\"Fractional component must be last\")\n                } else {\n                    result += component.toLong().toDuration(unit)\n                }\n            }\n        }\n    }\n    return if (isNegative) -result else result\n}\n\n\nprivate fun parseOverLongIsoComponent(value: String): Long {\n    val length = value.length\n    var startIndex = 0\n    if (length > 0 && value[0] in \"+-\") startIndex++\n    if ((length - startIndex) > 16 && (startIndex..value.lastIndex).all { value[it] in '0'..'9' }) {\n        // all chars are digits, but more than ceiling(log10(MAX_MILLIS / 1000)) of them\n        return if (value[0] == '-') Long.MIN_VALUE else Long.MAX_VALUE\n    }\n    // TODO: replace with just toLong after min JDK becomes 8\n    return if (value.startsWith(\"+\")) value.drop(1).toLong() else value.toLong()\n}\n\n\n\nprivate inline fun String.substringWhile(startIndex: Int, predicate: (Char) -> Boolean): String =\n    substring(startIndex, skipWhile(startIndex, predicate))\n\nprivate inline fun String.skipWhile(startIndex: Int, predicate: (Char) -> Boolean): Int {\n    var i = startIndex\n    while (i < length && predicate(this[i])) i++\n    return i\n}\n\n\n\n\n\n// The ranges are chosen so that they are:\n// - symmetric relative to zero: this greatly simplifies operations with sign, e.g. unaryMinus and minus.\n// - non-overlapping, but adjacent: the first value that doesn't fit in nanos range, can be exactly represented in millis.\n\ninternal const val NANOS_IN_MILLIS = 1_000_000\n// maximum number duration can store in nanosecond range\ninternal const val MAX_NANOS = Long.MAX_VALUE / 2 / NANOS_IN_MILLIS * NANOS_IN_MILLIS - 1 // ends in ..._999_999\n// maximum number duration can store in millisecond range, also encodes an infinite value\ninternal const val MAX_MILLIS = Long.MAX_VALUE / 2\n// MAX_NANOS expressed in milliseconds\nprivate const val MAX_NANOS_IN_MILLIS = MAX_NANOS / NANOS_IN_MILLIS\n\nprivate fun nanosToMillis(nanos: Long): Long = nanos / NANOS_IN_MILLIS\nprivate fun millisToNanos(millis: Long): Long = millis * NANOS_IN_MILLIS\n\n@ExperimentalTime private fun durationOfNanos(normalNanos: Long) = Duration(normalNanos shl 1)\n@ExperimentalTime private fun durationOfMillis(normalMillis: Long) = Duration((normalMillis shl 1) + 1)\n@ExperimentalTime private fun durationOf(normalValue: Long, unitDiscriminator: Int) = Duration((normalValue shl 1) + unitDiscriminator)\n@ExperimentalTime private fun durationOfNanosNormalized(nanos: Long) =\n    if (nanos in -MAX_NANOS..MAX_NANOS) {\n        durationOfNanos(nanos)\n    } else {\n        durationOfMillis(nanosToMillis(nanos))\n    }\n\n@ExperimentalTime private fun durationOfMillisNormalized(millis: Long) =\n    if (millis in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) {\n        durationOfNanos(millisToNanos(millis))\n    } else {\n        durationOfMillis(millis.coerceIn(-MAX_MILLIS, MAX_MILLIS))\n    }\n\n\ninternal expect fun formatToExactDecimals(value: Double, decimals: Int): String\ninternal expect fun formatUpToDecimals(value: Double, decimals: Int): String",null,null,null,null,null,null,null],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;uBAwB8D,+B;qBACA,+B;WAwRtC,gB;;;;;;;YA5JsC,uB;;;;;;oBAyIzB,+B;YCmvBW,8B;2BCjoBhD,qC;;WCxRmE,e;;;;;;;;;iCCmUlD,qB;iCAzLS,qB;YA6FjB,mB;wBA8HiC,iC;uBACE,gC;oBCpVM,sB;;;;;;;;;;;kBCqalD,K;kBC/QA,0C;mBC9QA,2G;iBC2DA,e;;;;;;;;;;;;;;;;;;;;;oBCgFA,sC;iBAAA,qC;oBAAA,kB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IC1II,6B;;EAJA,wB;IAAA,4B;G;+BACI,Y;IAA8B,OAA+B,+BAAQ,M;G;;;;;;;EADzE,oC;IAAA,mC;MAAA,kB;KAAA,4B;G;EAIA,6B;IAAA,+B;G;;;;;;;EAAA,uC;IAAA,sC;MAAA,uB;KAAA,+B;G;;;;;;EAKJ,sC;IACQ,OAAM,kBAAN,eAAM,EAAgB,QAAhB,CAA0B,K;G;EAIM,uD;IAAA,0C;G;iDAC1C,Y;IAAmC,2BAAgB,4BAAhB,EAAuB,sBAAvB,C;G;;;;;EAFvC,iC;IAC8C,gD;G;EAKjB,yC;IAA2D,mB;IAA1D,wB;IAA8B,oB;G;yCACxD,Y;IAAsC,OAAA,YAAM,MAAN,eAAc,cAAd,C;G;0CAEtC,oB;IAAkD,2BAAgB,2BAAU,QAAV,CAAhB,EAAoC,YAApC,C;G;2CAElD,oB;IAAmD,2BAAgB,4BAAU,QAAV,CAAhB,EAAoC,YAApC,C;G;;;;;;EXzBvD,0B;IA0DI,sC;G;;;SAnDsB,Y;MAAQ,0BAAc,EAAd,I;K;;;;SACP,Y;MAAQ,0BAAc,E;K;;;;SAClB,Y;MAAQ,OAAC,yCAAsC,Q;K;;;;SAC7C,Y;MAAQ,OAAE,4CAAD,kBAAyD,Q;K;;;;SAClE,Y;MAAQ,OAAE,0CAAD,yBAAsC,UAAtC,EAAqD,Q;K;;;;SAC1D,Y;MAAQ,OAAC,iDAAmB,UAAnB,EAAkC,Q;K;;sDAE5E,Y;IACI,2BAAe,CAAf,IAAoB,aAAQ,CAA5B,IAAiC,oCAAoB,CAArD,KAA2D,oBAAe,SAAf,MAAuB,CAAvB,IAA4B,kCAAvF,C;G;sCAEJ,Y;IEwXuB,gBAAhB,oB;IFvXQ,gB;IAAA,IAAI,+BAAJ,C;MYkDf,SZlDuC,gBAAO,EAAP,C;MAAa,S;;MAAU,Q;IAA1D,e;IYkDJ,SZjDI,gBAAO,EAAP,C;IACA,IAAI,eAAS,CAAb,C;MYgDJ,SZhDoB,gBAAO,wBAAQ,IAAR,CAAP,CAAqB,gBAAO,EAAP,C;IACrC,IAAI,gBAAU,CAAd,C;MY+CJ,SZ/CqB,gBAAO,yBAAS,IAAT,CAAP,CAAsB,gBAAO,EAAP,C;IACvC,IAAI,cAAQ,CAAZ,C;MY8CJ,SZ9CmB,gBAAO,uBAAO,IAAP,CAAP,CAAoB,gBAAO,EAAP,C;IACnC,YAAQ,GAAR,C;IACA,IAAI,eAAS,CAAb,C;MY4CJ,SZ5CoB,gBAAO,GAAP,CAAU,gBAAO,wBAAQ,IAAR,CAAP,CAAqB,gBAAO,EAAP,C;MAAmB,MAAI,E;KACtE,IAAI,iBAAW,CAAf,C;MY2CJ,SZ3CsB,gBAAO,GAAP,CAAU,gBAAO,0BAAU,IAAV,CAAP,CAAuB,gBAAO,EAAP,C;MAAmB,MAAI,E;KAC1E,IAAI,gBAAW,gBAAX,MAA0B,CAA9B,C;MY0CJ,SZzCQ,gBAAO,GAAP,C;MAEI,qBAAW,CAAX,C;QAAgB,mCAAU,IAAV,C;WAChB,kCAAc,IAAd,IAAqB,CAArB,C;QAA0B,a;;QAClB,Y;MYqCpB,SZxCQ,uB;MAKA,IAAI,qBAAe,CAAnB,C;QYmCR,SZnC8B,gBAAO,EAAP,CAAY,gBAA8C,SCk+BpC,IDl+BF,gBCk+BE,CDl+ByB,WAAW,EAAS,CAAT,EAAY,EAAZ,CAA9C,C;OYmC1C,SZlCQ,gBAAO,EAAP,C;KAGJ,IY+BJ,SZ/BQ,YAAU,CAAd,C;MY+BJ,SZ/BqB,gBAAO,IAAP,C;IApBa,OYoD3B,SVoUqC,W;G;oCFjW5C,iB;IACI,IAAI,SAAS,KAAb,C;MAAoB,OAAO,I;IAC3B,IAAI,qCAAJ,C;MAA8B,OAAO,K;IAErC,IAAI,qBAAe,KAAM,YAAzB,C;MAAsC,OAAO,K;IAC7C,IAAI,cAAQ,KAAM,KAAlB,C;MAAwB,OAAO,K;IAC/B,IAAI,+BAAoB,KAAM,iBAA1B,CAAJ,C;MAAgD,OAAO,K;IAEvD,OAAO,I;EACX,C;sCAEA,Y;IACI,aAAa,gB;IACb,SAAS,MAAK,MAAL,QAAc,SAAd,I;IACT,SAAS,MAAK,MAAL,QAA+B,SAAjB,qBAAiB,CAA/B,I;IACT,OAAO,M;EACX,C;EAEA,oC;IAAA,wC;G;EAEQ,0E;IACI,MAAM,+BAAwB,yBAAsB,QAAtB,UAAiC,OAAzD,C;G;EAoFN,8F;IAAA,uC;MACI,IAAI,uBAAO,WAAP,IAAwB,uBAAO,UAAnC,C;QACI,uBAAe,WAAQ,SAAR,mGAAyE,SAAzE,OAAf,EAAqG,cAArG,C;MACJ,OAAO,iB;IACX,C;G;qDA1FR,gB;IAgC4B,UAyBd,M;IAxDV,kE;IAEA,YAAY,C;IACZ,cAAc,C;IACd,iBAAiB,C;IACjB,kBAAkB,C;IAClB,iBAAiB,C;IACjB,gBAAgB,C;IAChB,cAAc,C;IACd,iBAAiB,C;IACjB,mBAAmB,C;IACnB,4BAA4B,C;IAE5B,YAAY,K;IAEZ,QAAQ,C;IACR,WAAW,C;IACX,YAAY,C;IACZ,aAAa,C;IACb,YAAY,C;IACZ,WAAW,C;IACX,YAAY,C;IACZ,cAAc,C;IACd,cAAc,C;IACd,kBAAkB,C;IAClB,OAAO,IAAP,C;MACI,IAAI,KAAK,IAAK,OAAd,C;QACI,IAAI,UAAS,KAAb,C;UACI,eAAe,qDAAf,EAAsE,CAAtE,C;QACJ,IAAI,UAAS,OAAb,C;UACI,eAAe,4EAAf,EAA6F,CAA7F,C;QACkB,QAAa,oBAAL,IAAK,CAAL,yBAAgB,QAAQ,CAAR,IAAhB,E;QAC1B,aAAG,0BAAe,UAAf,CAAH,K;UAAqC,OAAF,CAAE,Q;;UAC7B,sBAAe,+EAAf,EAAgG,CAAhG,C;QAFZ,oB;QAIA,OAAO,iBAAe,KAAf,EAAsB,MAAtB,EAA8B,SAA9B,EAAyC,KAAzC,EAAgD,OAAhD,EAAyD,OAAzD,EAA8E,oBAAZ,WAAY,CAA9E,C;OAEX,IAAI,UAAS,KAAb,C;QACI,IAAI,KAAI,CAAJ,SAAS,IAAK,OAAd,KAAyB,gBAAK,CAAL,MAAW,EAAX,IAAkB,gBAAK,CAAL,MAAW,EAAtD,CAAJ,C;UACI,eAAe,sDAAf,EAAuE,CAAvE,C;QACJ,QAAM,gBAAK,CAAL,CAAN,C;eACI,E;eAAA,E;YACI,IAAI,gBAAK,CAAL,MAAW,EAAf,C;cACI,OAAO,E;YACX,IAAI,gBAAK,IAAI,CAAJ,IAAL,MAAe,EAAnB,C;cACI,eAAe,4CAAsB,gBAAK,IAAI,CAAJ,IAAL,CAAtB,OAAf,EAAqD,IAAI,CAAJ,IAArD,C;YACJ,QAAK,CAAL,I;YALJ,K;eAOA,E;YAAS,QAAK,CAAL,I;YAAT,K;kBACQ,eAAe,sDAAgC,gBAAK,CAAL,CAAhC,OAAf,EAA2D,CAA3D,C;YATZ,K;;QAWA,QAAQ,O;QACR,Q;OAEJ,gBAAgB,I;MAChB,aAAa,C;MACP,yBAAK,CAAL,C;MAAN,e;aACI,E;aAAA,E;UACI,IAAI,gBAAK,CAAL,MAAW,EAAf,C;YAAoB,wBAAa,EAAb,I;UACpB,QAAK,CAAL,I;UACA,IAAI,KAAK,IAAK,OAAV,IAAoB,EAAY,kBAAK,EAAL,CAAZ,mCAAK,CAAL,EAAxB,C;YACI,eAAe,kDAA4B,gBAAK,CAAL,CAA5B,OAAf,EAAuD,CAAvD,C;UAJR,K;gBAMA,MAAG,kBAAK,EAAL,CAAH,2B;YACA,kB;cACI,IAAI,SAAS,OAAb,C;gBACI,eAAe,oCAAf,EAAqD,CAArD,C;cACJ,QAAQ,O;cACR,QAAK,CAAL,I;cACA,Q;;UAbR,K;;MAgBA,e;MACA,OAAO,IAAI,IAAK,OAAT,IAAmB,CAAW,kBAAK,EAAL,CAAX,mCAAK,CAAL,EAA1B,C;;UAEQ,SAAS,QAAQ,aAAa,MAAb,MAAR,EAAkD,oBAAf,gBAAK,CAAL,IAAU,EAAK,CAAlD,C;;UACX,0C;YACE,eAAe,yBAAf,EAA0C,MAA1C,C;;YAHJ,O;;QAKA,QAAK,CAAL,I;;MAEJ,6CAAU,SAAV,E;MACA,IAAI,MAAK,IAAK,OAAd,C;QACI,eAAe,iDAAf,EAAkE,CAAlE,C;MACJ,iBAAiB,8F;MACjB,wF;MAKA,QAAc,cAAR,gBAAK,CAAL,CAAQ,CAAd,C;aACI,E;UACI,IAAI,SAAS,UAAb,C;YACI,eAAe,UAAf,EAA2B,CAA3B,C;UACJ,QAAQ,U;UACR,QAAe,cAAP,MAAO,EAAc,EAAd,C;UAJnB,K;aAMA,E;UACI,IAAI,SAAS,OAAb,C;YAEI,IAAI,SAAS,YAAb,C;cACI,eAAe,UAAf,EAA2B,CAA3B,C;YACJ,QAAQ,Y;YACR,UAAiB,cAAP,MAAO,EAAc,EAAd,C;;YAGjB,IAAI,SAAS,WAAb,C;cACI,eAAe,UAAf,EAA2B,CAA3B,C;YACJ,QAAQ,W;YACR,SAAgB,cAAP,MAAO,EAAc,EAAd,C;;;UAZxB,K;aAeA,E;UACI,IAAI,SAAS,UAAb,C;YACI,eAAe,UAAf,EAA2B,CAA3B,C;UACJ,QAAQ,U;UACR,QAAe,cAAP,MAAO,EAAc,EAAd,C;UAJnB,K;aAMA,E;UACI,IAAI,SAAS,SAAb,C;YACI,eAAe,UAAf,EAA2B,CAA3B,C;UACJ,QAAQ,S;UACR,OAAc,cAAP,MAAO,EAAc,EAAd,C;UAJlB,K;aAMA,E;UACI,IAAI,SAAS,UAAT,IAAuB,QAAQ,OAAnC,C;YACI,eAAe,UAAf,EAA2B,CAA3B,C;UACJ,QAAQ,U;UACR,QAAe,cAAP,MAAO,EAAc,EAAd,C;UAJnB,K;aAMA,E;UACI,IAAI,SAAS,qBAAT,IAAkC,QAAQ,OAA9C,C;YACI,eAAe,UAAf,EAA2B,CAA3B,C;UACJ,QAAQ,qB;UACR,UAAiB,cAAP,MAAO,EAAc,EAAd,C;UAJrB,K;aAMA,E;aAAA,E;UACI,QAAK,CAAL,I;UACA,IAAI,KAAK,IAAK,OAAd,C;YACI,eAAe,uDAAiC,gBAAK,IAAI,CAAJ,IAAL,CAAjC,CAAf,EAA+D,CAA/D,C;UACJ,qBAAqB,C;UACrB,OAAO,IAAI,IAAK,OAAT,IAAmB,CAAW,kBAAK,EAAL,CAAX,mCAAK,CAAL,EAA1B,C;YACI,QAAK,CAAL,I;UACJ,qBAAqB,IAAI,cAAJ,I;UACrB,IAAI,iBAAiB,CAArB,C;YACI,eAAe,yDAAf,EAA0E,cAA1E,C;UACsB,eAA0B,C;UAApD,qBAAqB,IaQmD,WbRpC,caQoC,EAAsB,QAAtB,CbRnD,GAAwC,OAAJ,GAAI,EAAO,IAAI,cAAJ,IAAP,C;UAC7D,cAAc,YAAe,MAAf,cAAe,EAAM,EAAN,CAAf,EAA2B,SAA3B,C;UACd,IAAI,gBAAK,CAAL,MAAW,EAAf,C;YACI,eAAe,8CAAf,EAA+D,CAA/D,C;UACJ,IAAI,SAAS,qBAAT,IAAkC,QAAQ,OAA9C,C;YACI,eAAe,UAAf,EAA2B,CAA3B,C;UACJ,QAAQ,qB;UACR,UAAiB,cAAP,MAAO,EAAc,EAAd,C;UAjBrB,K;gBAmBQ,eAAe,iDAAf,EAAkE,CAAlE,C;UAjEZ,K;;MAmEA,QAAK,CAAL,I;;EAER,C;kDAjKJ,Y;;G;;;;;;;EAAA,gD;IAAA,+C;MAAA,8B;KAAA,wC;G;;;;;;EAqKJ,qC;IAAuD,OAAA,sCAAe,eAAM,SAAN,C;G;EAG9C,uC;IAYpB,kC;IATA,yB;IAFA,wC;IACA,0B;G;;SADA,Y;MAAA,iC;K;;;SACA,Y;MAAA,0B;K;;;;SAIwB,Y;MAAQ,Q;K;;;;SACN,Y;MAAQ,Q;K;;;;SACR,Y;MAAQ,Q;K;;;;SACJ,Y;MAAQ,Q;K;;;;SACO,Y;MAAQ,S;K;;EAErD,gC;IAAA,oC;G;iDACI,gB;IACU,aAAa,sCAAe,eAAM,IAAN,C;IAC9B,sC;MADJ,OACqB,M;;MACT,MAAM,+BAAwB,YAAS,MAAT,6BAAqC,IAArC,wBAAxB,C;G;8CAJ1B,Y;;G;;;;;;;EAAA,4C;IAAA,2C;MAAA,0B;KAAA,oC;G;;;;;;EARA,qD;IAAmB,qB;MAAA,QAAa,C;IAAG,sB;MAAA,SAAc,C;IAAG,oB;MAAA,OAAY,C;IAAhE,oD;IAAoE,uBAAK,YAAY,KAAZ,EAAmB,MAAnB,CAAL,EAAiC,IAAjC,C;IAApE,Y;G;EAiBJ,iC;IAA+C,OAAA,kCAAW,eAAM,SAAN,C;G;EAE1B,iE;IAI5B,yB;IAHA,wC;IACA,0B;IACA,kD;G;;SAFA,Y;MAAA,iC;K;;;SACA,Y;MAAA,0B;K;;;SACA,Y;MAAA,sC;K;;;;;;;EAGJ,oC;IAEU,kBAAwB,oBAAN,KAAM,CAAN,8BAAiB,EAAjB,OAA6B,oBAAP,MAAO,CAA7B,C;IACpB,aAAG,0BAAe,UAAf,CAAH,e;MADJ,OACuC,WAAY,Q;;MACvC,MAAM,8BAAyB,mCAAgC,KAAhC,mBAAiD,MAAjD,6BAAzB,C;G;EAGtB,gE;IASW,Q;IARP,mBAA+B,oBAAN,KAAM,CAAN,8BAAiB,EAAjB,2BAAsB,OAAtB,E;IAEzB,4BAAkC,0CAAe,EAAf,E;IAElC,qCAA2C,0BAAwB,oCAAc,UAAd,EAAxB,C;IAE3C,mBAAmB,uDAAiC,OAAjC,E;;MAGf,sBAAe,YAAf,eAA4C,uCAAc,UAAd,EAA5C,C;;MACF,0C;QACE,MAAM,8BAAyB,wCAAqC,KAArC,gBAAmD,OAAnD,kBAAqE,OAArE,sBAA2F,WAA3F,6CAAzB,C;;QAHH,O;;IAAP,W;EAKJ,C;EAEA,kE;IAAiC,2B;MAAA,cAAmB,C;IAAG,oB;MAAA,OAAY,C;IAC/D,OAAI,6BAAJ,GACI,uBAAmB,WAAnB,EAAgC,IAAhC,EAAsC,gBAAtC,CADJ,GAGI,eAAW,WAAX,EAAwB,IAAxB,C;G;EAER,qF;IACI,qB;MAAA,QAAa,C;IACb,sB;MAAA,SAAc,C;IACd,oB;MAAA,OAAY,C;IACZ,qB;MAAA,QAAa,C;IACb,uB;MAAA,UAAe,C;IACf,uB;MAAA,UAAe,C;IACf,2B;MAAA,gB;IACgB,2BAAoB,YAAY,KAAZ,EAAmB,MAAnB,CAApB,EAAgD,IAAhD,EAChB,iBAAiB,KAAjB,EAAwB,OAAxB,EAAiC,OAAjC,EAA0C,WAA1C,CADgB,C;G;EAGpB,uC;IACyD,2CAAuC,4BAAvC,C;G;EAEzD,gC;IAAiF,2BAC7E,UAAQ,qBAAR,EAAqB,KAAM,YAA3B,CAD6E,EAE7E,UAAQ,cAAR,EAAc,KAAM,KAApB,CAF6E,EAG7E,QAAQ,0BAAR,EAA0B,KAAM,iBAAhC,CAH6E,C;G;EAMjF,kC;IAAqE,sBACjE,UAAQ,qBAAR,EAAqB,KAAM,YAA3B,CADiE,EAEjE,UAAQ,cAAR,EAAc,KAAM,KAApB,CAFiE,C;G;EGnTrE,wB;IA4GI,oC;G;EAtGsB,6C;;IAAiC,uB;IAAhC,8B;IACnB,sB;IACA,uB;IWgBJ,IAAI,EXbY,8BAAc,CWa1B,CAAJ,C;MACI,cXd+B,6CAA0C,gBAA1C,oB;MWe/B,MAAM,8BAAyB,OAAQ,WAAjC,C;KXZE,wD;MACI,kBAAW,M;MACX,mBAAY,oC;WAEhB,sD;MACI,kBAAW,Q;MACX,mBAAY,kC;WAEhB,uDAAc,UAAd,Q;MACI,kBAAW,Q;MACX,mBAAY,yCAAc,UAAd,E;WAEhB,uDAAc,OAAd,Q;MACI,kBAAW,a;MACX,mBAAY,yCAAc,OAAd,E;WAEhB,uDAAc,IAAd,Q;MACI,kBAAW,a;MACX,mBAAY,yCAAc,IAAd,E;;MAGZ,kBAAW,Y;MACX,mBAAY,gB;;G;mDAKxB,kB;IAA6C,kCAAU,aAAa,gBAAb,EAAiC,oBAAP,MAAO,CAAjC,CAAV,C;G;;;SAIzC,Y;MAAQ,OAAA,kBAAS,qBAAY,gBAAZ,C;K;;4CAErB,iB;IACQ,gBAAS,KAAT,KAAmB,gDAAsB,OAAA,IAAK,YAAL,EAAoB,KAAM,YAA1B,CAAzC,C;G;8CAER,Y;IAA+B,OAAA,gBAAY,QAAZ,GAAyB,4BAAgB,EAAhB,CAA+B,Q;G;8CAEvF,Y;IAAkC,mCAAe,gBAAf,EAA0B,eAA1B,C;G;EA/CtC,4C;;G;0DAAA,Y;;G;;;;;;;;;;;;;;;;;EAkDA,kC;;IACgC,uB;G;EADhC,4C;;G;0DAAA,Y;;G;;;;;;;;;;;;;;;;;EAWqB,qC;;IAAyB,iC;IAAxB,gB;IW1CtB,IAAI,EX4CY,YAAO,CW5CnB,CAAJ,C;MACI,cX2CwB,6CAA0C,SAA1C,W;MW1CxB,MAAM,8BAAyB,OAAQ,WAAjC,C;M;kDX6CN,kB;IAAyD,OAAa,0BAAS,eAAa,SAAb,EAAmB,MAAnB,CAAT,C;G;2CAEtE,iB;IACI,gBAAS,KAAT,KAAmB,+CAAkC,IAAK,KAAL,KAAa,KAAM,KAAxE,C;G;6CAEJ,Y;IAA+B,mBAAS,K;G;6CAExC,Y;IAAkC,OAAI,YAAO,CAAP,KAAY,CAAhB,GAC9B,4BAAe,YAAO,CAAP,IAAf,EAAyB,MAAzB,CAD8B,GAG9B,4BAAe,SAAf,EAAqB,KAArB,C;G;EAhBR,2C;;G;yDAAA,Y;;G;;;;;;;;;;;;;;;;;EAoBuB,yC;;IAA2B,iC;IAA1B,oB;IW7DxB,IAAI,EX+DY,cAAS,CW/DrB,CAAJ,C;MACI,cX8D0B,6CAA0C,WAA1C,a;MW7D1B,MAAM,8BAAyB,OAAQ,WAAjC,C;M;oDXgEN,kB;IAA2D,OAAa,4BAAW,eAAa,WAAb,EAAqB,MAArB,CAAX,C;G;6CAExE,iB;IACI,gBAAS,KAAT,KAAmB,iDAAoC,IAAK,OAAL,KAAe,KAAM,OAA5E,C;G;+CAEJ,Y;IAA+B,qBAAW,M;G;+CAE1C,Y;IACI,kBAAS,IAAT,KAAkB,CAAlB,C;MAD8B,OACP,4BAAe,cAAS,IAAT,IAAf,EAA+B,SAA/B,C;SACvB,kBAAS,EAAT,KAAe,CAAf,C;MAF8B,OAEV,4BAAe,cAAS,EAAT,IAAf,EAA4B,MAA5B,C;SACpB,kBAAS,CAAT,KAAc,CAAd,C;MAH8B,OAGX,4BAAe,cAAS,CAAT,IAAf,EAA2B,SAA3B,C;;MAHW,OAItB,4BAAe,WAAf,EAAuB,OAAvB,C;G;EAjBhB,6C;;G;2DAAA,Y;;G;;;;;;;;;;;;;;;;;kDAqBA,uB;IAAiE,OAAI,UAAS,CAAb,GAAgB,IAAhB,GAA4B,KAAF,oBAAS,I;G;kDACpG,uB;IAAkE,OAAI,iBAAJ,GAAiB,IAAjB,GAA6B,KAAF,oBAAS,I;G;EAEtG,kC;IAAA,sC;IACI,kBAAmC,8B;IACnC,mBAAoC,8BAAa,IAAb,C;IACpC,mBAAoC,+BAAc,IAAd,C;IACpC,cAA+B,+BAAc,IAAd,C;IAC/B,cAA+B,0BAAS,EAAT,C;IAC/B,YAA6B,0BAAS,EAAT,C;IAC7B,WAA2B,0BAAgB,CAAhB,C;IAC3B,YAA4B,uBAAM,CAAN,C;IAC5B,aAA+B,4BAAoB,CAApB,C;IAC/B,eAAiC,yBAAQ,CAAR,C;IACjC,YAA8B,yBAAQ,EAAR,C;IAC9B,eAAiC,wBAAO,GAAP,C;G;gDAZrC,Y;;G;;;;;;;EAAA,8C;IAAA,6C;MAAA,4B;KAAA,sC;G;;;;;;EYpGmC,qC;IAAQ,2BAAU,CAAV,I;G;;EAI/C,iC;IDYI,IAAI,ECXoB,CAAhB,oCAAmB,CDWvB,CAAJ,C;MACI,cAda,qB;MAeb,MAAM,8BAAyB,OAAQ,WAAjC,C;KCZV,OAAO,0BAAc,eAAe,CAAf,IAAd,C;EACX,C;;;;;;;;;EClBI,iD;IAAA,qE;IAAsB,4B;IAD1B,uC;IACI,Y;G;EACA,4D;IAAA,qE;IAAqC,wBAAM,OAAN,Q;IAFzC,uC;IAEI,Y;G;EACA,0D;IAAA,qE;IAAsC,wBAAM,KAAN,Q;IAH1C,uC;IAGI,Y;G;EACA,mE;IAAA,qE;IAAuD,6BAAM,OAAN,EAAe,KAAf,C;IAJ3D,uC;IAII,Y;G;;;;;;;;;EAIA,8C;IAAA,kE;IAAsB,sC;IAD1B,oC;IACI,Y;G;EACA,yD;IAAA,kE;IAAqC,8BAAM,OAAN,Q;IAFzC,oC;IAEI,Y;G;EACA,uD;IAAA,kE;IAAsC,gCAAM,KAAN,Q;IAH1C,oC;IAGI,Y;G;EACA,gE;IAAA,kE;IAAuD,qCAAM,OAAN,EAAe,KAAf,C;IAJ3D,oC;IAII,Y;G;;;;;;;;;EAIA,6C;IAAA,iE;IAAe,sC;IADnB,mC;IACI,Y;G;EACA,wD;IAAA,iE;IAA8B,8BAAM,OAAN,Q;IAFlC,mC;IAEI,Y;G;EACA,sD;IAAA,iE;IAA+B,gCAAM,KAAN,Q;IAHnC,mC;IAGI,Y;G;EACA,+D;IAAA,iE;IAAgD,qCAAM,OAAN,EAAe,KAAf,C;IAJpD,mC;IAII,Y;G;EZ8IA,sC;IAAQ,iCAAQ,+BAAQ,aAAhB,M;G;EAIR,wC;IAAQ,iCAAQ,+BAAQ,eAAhB,M;G;EAEZ,8B;IAQyC,OAAA,+BAAQ,eAAM,SAAN,C;G;EAWjD,4C;IAWI,IAAI,QAAA,MAAO,iBAAP,2BAAJ,C;MACI,oBAAmC,oBAAoB,CAA9B,MAA+B,YAAD,IAApB,EAAkC,CAA5C,MAA6C,KAAD,IAAlC,EAAV,MAAoD,iBAAD,aAAzC,C;MADvC,OAEI,kBAAK,aAAL,EAAoB,QAApB,C;;MAEA,sBAAmC,oBAAoB,CAA9B,MAA+B,YAAD,IAApB,EAAkC,CAA5C,MAA6C,KAAD,IAAlC,EAAV,MAAqD,0CAAiB,CAAjB,EAAF,aAAzC,C;MAJvC,OAKkC,OAA9B,kBAAK,eAAL,EAAoB,QAApB,CAA8B,EAAK,oCAAa,WAAlB,C;;G;EAiCtC,uC;;MAWI,OACI,qBAAqB,KAAM,aAAN,UAAqB,sBAArB,CAArB,eAEsD,oBAAjD,KAAM,oBAAN,GAA4B,6BAA5B,IAAiD,CAFtD,EAGI,IAAK,YAHT,C;;MAIF,0C;QALF,OAMQ,0BAAO,KAAP,KAAJ,sD;;QANJ,O;;G;EASJ,+C;IASQ,OAAyC,WAAzC,mBAAM,KAAN,EAAa,oCAAa,IAA1B,EAA+B,QAA/B,CAAyC,C;G;EAEjD,iD;IASQ,OAA2C,WAA3C,mBAAM,KAAN,EAAa,oCAAa,MAA1B,EAAiC,QAAjC,CAA2C,C;G;EAEnD,gD;IASQ,OAA0C,WAA1C,mBAAM,KAAN,EAAa,oCAAa,KAA1B,EAAgC,QAAhC,CAA0C,C;G;EAElD,6C;IAeQ,OAAM,YAAN,KAAM,EAAY,SAAZ,EAAkB,QAAlB,C;G;EAad,4C;IASI,yBAAK,EAAL,EAAS,IAAT,EAAe,QAAf,C;G;EAEJ,iC;IAQI,6BAAS,IAAT,C;G;EAEJ,kC;IAQI,8BAAU,IAAV,C;G;EAwBJ,wC;IASI,yBAAW,oBAAN,KAAM,CAAX,EAAqB,IAArB,C;G;EAEJ,yC;IASI,0BAAY,oBAAN,KAAM,CAAZ,EAAsB,IAAtB,C;G;EAaJ,mD;IAUI,IAAI,wCAAJ,C;MAAA,OACI,kBAAM,KAAD,aAAL,EAAa,IAAb,EAAmB,QAAnB,C;;MADJ,OAGuC,OAAnC,kBAAO,8BAAQ,CAAR,EAAF,aAAL,EAAmB,IAAnB,EAAyB,QAAzB,CAAmC,EAAK,IAAL,EAAW,QAAX,C;;G;EAa3C,yC;IASI,IAAI,wCAAJ,C;MAAA,OACI,kBAAM,KAAD,aAAL,EAAa,IAAb,C;;MADJ,OAG6B,OAAzB,kBAAO,8BAAQ,CAAR,EAAF,aAAL,EAAmB,IAAnB,CAAyB,EAAK,IAAL,C;;G;EAGjC,mD;IAaQ,OAAM,QAAN,KAAM,EAAM,SAAN,EAAY,IAAZ,EAAkB,QAAlB,C;G;EAEd,yC;IAWI,OAAM,MAAN,KAAM,EAAM,SAAN,EAAY,IAAZ,C;G;;;EapYV,gC;IAO6C,OAAA,iCAAU,eAAM,SAAN,C;G;EAEvD,6D;IAMoD,sB;MAAA,SAAc,C;IAAG,0B;MAAA,aAAkB,C;IACnF,0BAAc,cAAd,EAAoB,qBAApB,EAAiC,oBAAjC,EAA6C,IAA7C,EAAmD,MAAnD,EAA2D,MAA3D,EAAmE,UAAnE,C;G;EAaJ,oC;IASI,IAAI,MAAO,KAAP,KAAe,WAAf,IAAgC,MAAO,OAAP,KAAiB,WAArD,C;MAAA,OACI,mBAAoB,gBAAW,CAArB,MAAsB,MAAD,IAAX,EAAmB,CAA7B,MAA8B,OAAD,IAAnB,EAA4B,CAAtC,MAAuC,KAAD,IAA5B,CAApB,C;;MADJ,OAKI,SADA,SADA,oBAAM,MAAO,MAAb,EAAoB,oCAAa,KAAjC,CACA,EAAM,MAAO,OAAb,EAAqB,oCAAa,MAAlC,CACA,EAAM,MAAO,KAAb,EAAmB,oCAAa,IAAhC,C;;G;EAmBR,mC;IAcoE,OAAM,cAAN,KAAM,EAAY,SAAZ,C;G;EAkD1E,mC;IAOsE,yBAAK,EAAL,EAAS,IAAT,C;G;EAgCtE,0C;IAQmF,0BAAM,KAAD,aAAL,EAAa,IAAb,C;G;ECrJnF,oC;IAQqD,OAAA,qCAAc,eAAM,SAAN,C;G;EC7FtC,+B;IAAQ,2BAAU,CAAV,I;G;;EAKrC,uB;ILII,IAAI,EKHc,CAAV,wBAAa,ELGjB,CAAJ,C;MACI,cAda,qB;MAeb,MAAM,8BAAyB,OAAQ,WAAjC,C;KKJV,OAAO,sBAAU,SAAS,CAAT,IAAV,C;EACX,C;ECuFA,uC;IAOQ,OAAS,SAAT,QAAS,EAAS,SAAT,C;G;EC3GjB,qB;IACoC,OAAA,iCAAU,K;G;EAE9C,+B;IAAyD,gCAAoB,SAApB,C;G;EhBjBzD,+B;IAEY,2BAAO,UAAP,C;MADJ,OAC4B,U;SACxB,2BAAO,WAAP,C;MAFJ,OAE4B,W;;MAF5B,OAGY,iB;G;;;;EAYpB,kC;IAGQ,WADE,CACF,O;MACI,IAAI,mCAAJ,C;QACI,S;OAEJ,OAAQ,CAAD,a;WAEX,WAPE,CAOF,M;MAAM,OAAO,C;IAEjB,YAAY,WAAI,CAAJ,C;IACZ,IAAI,kBAAQ,CAAR,GAAa,CAAb,CAAJ,C;MACI,S;KAEJ,OAAO,K;EACX,C;EAEA,oC;IAOI,IAAI,iBAAW,aAAf,C;MAAwB,OAAO,wB;IAC/B,SAAS,mBAAmB,CAAnB,EAAsB,CAAtB,C;IACT,IAAI,eAAJ,C;MAAc,OAAO,iBAAa,OAAK,CAAL,CAAb,EAAqB,UAAK,CAAL,CAArB,C;IAGrB,IAAI,UAAK,CAAL,CAAJ,C;MAAY,OAAO,iBAAa,CAAb,K;IACnB,IAAI,UAAK,CAAL,CAAJ,C;MAAY,OAAO,iBAAa,CAAb,K;IAYnB,SAAa,gBAAK,CAAT,W;IACT,SAAa,gBAAK,CAAT,W;IAET,SAAa,CAmEiB,iB;IAlE9B,SAAc,CAoEkB,YAAM,EAAN,CAAD,iB;IAnE/B,SAAa,CAiEiB,iB;IAhE9B,SAAc,CAkEkB,YAAM,EAAN,CAAD,iB;IA7D/B,QAAQ,YAAK,EAAL,MAAU,YAAK,EAAL,CAAV,C;IACR,QAAQ,YAAK,EAAL,MAAU,YAAK,EAAL,CAAV,MAAoB,YAAK,EAAL,CAApB,C;IACR,SAAS,YAAK,EAAL,C;IACT,SAAS,YAAK,EAAL,C;IACT,QAAQ,YAAK,EAAL,C;IAER,SAAa,CAqDiB,iB;IApD9B,UAAc,EAoDgB,iBApDpB,KAAc,EAoDM,iBApDpB,MAAyB,CAsDH,YAAM,EAAN,CAAD,iBAtDrB,C;IACV,SAAa,GAmDiB,iB;IAlD9B,UAAe,GAoDiB,YAAM,EAAN,CAAD,iBApDrB,KAAgB,CAkDI,iBAlDpB,MAA0B,EAoDJ,YAAM,EAAN,CAAD,iBApDrB,MAAqC,EAoDf,YAAM,EAAN,CAAD,iBApDrB,C;IACV,SAAa,GAiDiB,iB;IA9C9B,SAAc,GAgDkB,YAAM,EAAN,CAAD,iBAhDtB,KAAiB,CAgDM,YAAM,EAAN,CAAD,iBAhDtB,MAA0B,CA8CL,iBA9CrB,C;IAET,UAAW,aAAO,EAAP,CAAD,IAAe,EAAf,C;IACV,UAAW,aAAO,EAAP,CAAD,IAAe,EAAf,C;IAGV,WAAe,OAAS,GA6CgC,YA7C3B,EA6C2B,SA7CzC,KAAJ,GAA6B,EAA7B,GAAqC,C;IAEhD,IAAI,SAAQ,EAAZ,C;MAEI,MAAM,GAAI,MAAJ,yBAAY,CAAZ,E;MACN,MAAM,GAAI,M;MACV,IAAI,eAAJ,C;QACI,kCAAO,CAAP,E;KAKR,U;IAEA,U;IAEA,iBAAc,GAAd,WAAyB,CAAzB,U;MAEI,cAAkB,QAAQ,EAA1B,GAAuC,GA2Ba,YA3BR,KA2BQ,SA3BpD,GAAiE,GA2Bb,YA3BkB,QAAQ,EAAR,IA2BlB,S;MAzBpD,IAAK,YAAM,CAAN,CAAD,IAAa,OAAb,C;MAEJ,IAAI,kBAAK,CAAL,UAAU,eAAI,CAAlB,C;QACI,eAAK,CAAL,C;QAEA,IAAI,QAAQ,EAAZ,C;UACI,IAAI,KAAM,aAAO,KAAP,CAAN,C;;UAEJ,MAAM,wBAAoB,sEAApB,C;;IAGlB,OAAO,iBAAa,mCAAO,CAAP,CAAb,EAAuB,mCAAO,CAAP,CAAvB,C;EACX,C;EAE2B,4B;IAAC,U;IAAa,U;G;sCACrC,Y;IAAkC,a;G;sCAClC,Y;IAAkC,a;G;;;;;;EAGtC,gB;IACkC,yB;G;EAClC,iB;IACmC,OAAC,aAAM,EAAN,CAAD,iB;G;EACnC,8B;IAE2D,OAAC,iBAAU,GAAV,S;G;EAG5D,0C;IAMI,SAAS,C;IACT,SAAS,C;IAET,IAAI,eAAI,CAAJ,IAAS,eAAI,CAAjB,C;MACI,a;MACA,YAAM,CAAN,C;WACG,IAAI,eAAI,CAAJ,IAAS,eAAI,CAAjB,C;MACH,a;MACA,iBAAM,CAAN,C;KAEJ,IAAI,cAAJ,C;MACI,OAAO,OAAK,CAAL,C;gBAEI,kBAAkB,EAAlB,EAAsB,CAAtB,EAAyB,CAAzB,C;IAAf,IAAK,sBAAL;MAAS,sB;IACT,OAAO,QAAQ,EAAR,EAAY,QAAQ,OAAK,CAAL,CAAR,EAAgB,QAAQ,UAAK,CAAL,CAAR,EAAgB,EAAhB,MAAsB,CAAtB,CAAhB,CAAZ,C;EACX,C;EAEA,iC;IAMI,SAAS,C;IACT,SAAS,C;IAET,IAAI,eAAI,CAAJ,IAAS,eAAI,CAAjB,C;MACI,a;MACA,YAAM,CAAN,C;WACG,IAAI,eAAI,CAAJ,IAAS,eAAI,CAAjB,C;MACH,a;MACA,iBAAM,CAAN,C;KAEJ,OAAO,QAAQ,aAAa,EAAb,EAAiB,CAAjB,CAAR,EAA6B,EAA7B,C;EACX,C;EiB1KA,6C;IAAA,iD;IAEI,4BACI,2BAA2B,gBAA3B,MAA6C,mDAA7C,C;G;;;SADJ,Y;MAAA,gC;K;;oEAWA,mB;IACY,iBAAgB,e;IAAhB,0B;IhB0hBZ,gBgB1hBI,OhB0hBY,wBAAe,UAAf,C;IAChB,SAAqB,I;;MgB1hBb,YAAY,C;MACZ,aAAa,C;MACb,WAAW,C;MACX,YAAY,C;MACZ,cAAc,C;MACd,cAAc,C;MACd,oB;YACK,OAAO,IAAP,C;QACK,YhBohBP,SgBphBmB,4BAAmB,eAAnB,C;QAAlB,c;eACI,C;YAAK,QhBmhBV,SgBnhBkB,0BAAiB,eAAjB,EAA6B,CAA7B,C;YAAb,K;eACA,C;YAAK,ShBkhBV,SgBlhBmB,0BAAiB,eAAjB,EAA6B,CAA7B,C;YAAd,K;eACA,C;YAAK,OhBihBV,SgBjhBiB,0BAAiB,eAAjB,EAA6B,CAA7B,C;YAAZ,K;eACA,C;YAAK,QhBghBV,SgBhhBkB,0BAAiB,eAAjB,EAA6B,CAA7B,C;YAAb,K;eACA,C;YAAK,UhB+gBV,SgB/gBoB,0BAAiB,eAAjB,EAA6B,CAA7B,C;YAAf,K;eACA,C;YAAK,UhB8gBV,SgB9gBoB,0BAAiB,eAAjB,EAA6B,CAA7B,C;YAAf,K;eACA,C;YAAK,chB6gBV,SgB7gBwB,2BAAkB,eAAlB,EAA8B,CAA9B,C;YAAnB,K;eACA,E;YAAgC,U;kBACxB,MAAM,4BAAuB,uBAAoB,KAA3C,C;;;MhB2gB1B,yBgBxgBI,iBAAe,KAAf,EAAsB,MAAtB,EAA8B,IAA9B,EAAoC,KAApC,EAA2C,OAA3C,EAAoD,OAApD,EAA6D,WAA7D,C;;MhBygBN,gC;QACE,KAAK,C;QACL,MAAM,C;;QAJV,O;;;MAOI,IAAI,UAAJ,C;QAAgB,SAAU,sBAAa,UAAb,C;;IgBniB1B,6B;G;kEAwBJ,0B;IACY,iBAAgB,e;ICua5B,gBDvaI,OCuaY,wBAAe,UAAf,C;IAChB,SAAqB,I;;MDtaT,IAAI,gBAAS,CAAb,C;QCwaR,SDxawB,0BAAiB,eAAjB,EAA6B,CAA7B,EAAgC,WAAhC,C;MAChB,IAAI,iBAAU,CAAd,C;QCuaR,SDvayB,0BAAiB,eAAjB,EAA6B,CAA7B,EAAgC,YAAhC,C;MACjB,IAAI,eAAQ,CAAZ,C;QCsaR,SDtauB,0BAAiB,eAAjB,EAA6B,CAA7B,EAAgC,UAAhC,C;MACf,IAAI,gBAAS,CAAb,C;QCqaR,SDrawB,0BAAiB,eAAjB,EAA6B,CAA7B,EAAgC,WAAhC,C;MAChB,IAAI,kBAAW,CAAf,C;QCoaR,SDpa0B,0BAAiB,eAAjB,EAA6B,CAA7B,EAAgC,aAAhC,C;MAClB,IAAI,kBAAW,CAAf,C;QCmaR,SDna0B,0BAAiB,eAAjB,EAA6B,CAA7B,EAAgC,aAAhC,C;MAClB,IAAI,sBAAe,CAAnB,C;QCkaR,SDla8B,2BAAkB,eAAlB,EAA8B,CAA9B,EAAmD,oBAAZ,iBAAY,CAAnD,C;;MCmahC,gC;QACE,KAAK,C;QACL,MAAM,C;;QAJV,O;;;MAOI,IAAI,UAAJ,C;QAAgB,SAAU,sBAAa,UAAb,C;;EDra9B,C;EA/CiD,wE;IACzC,e;IfoRR,cAAgC,W;IEvN4B,Q;IF0N5D,iBAAiC,CE1N2B,qBDxDrD,6DCwDqD,kCF0N3B,Y;IACjC,0BexRqB,OfwRrB,EAAqB,UAArB,EAAiC,WAAjC,EexR2C,IfwR3C,C;IevRQ,iB;IfmRR,gBAAgC,W;IEvN4B,U;IF0N5D,mBAAiC,CE1N2B,uBDxDrD,6DCwDqD,oCF0N3B,Y;IACjC,0BevRqB,QfuRrB,EAAqB,YAArB,EAAiC,aAAjC,EevR4C,IfuR5C,C;IetRQ,iB;IfkRR,gBAAgC,W;IEvN4B,U;IF0N5D,mBAAiC,CE1N2B,uBDxDrD,6DCwDqD,oCF0N3B,Y;IACjC,0BetRqB,MfsRrB,EAAqB,YAArB,EAAiC,aAAjC,EetR0C,IfsR1C,C;IerRQ,iB;IfiRR,gBAAgC,W;IEvN4B,U;IF0N5D,mBAAiC,CE1N2B,uBDxDrD,6DCwDqD,oCF0N3B,Y;IACjC,0BerRqB,OfqRrB,EAAqB,YAArB,EAAiC,aAAjC,EerR2C,IfqR3C,C;IepRQ,iB;IfgRR,gBAAgC,W;IEvN4B,U;IF0N5D,mBAAiC,CE1N2B,uBDxDrD,6DCwDqD,oCF0N3B,Y;IACjC,0BepRqB,SfoRrB,EAAqB,YAArB,EAAiC,aAAjC,EepR6C,IfoR7C,C;IenRQ,iB;If+QR,gBAAgC,W;IEvN4B,U;IF0N5D,mBAAiC,CE1N2B,uBDxDrD,6DCwDqD,oCF0N3B,Y;IACjC,0BenRqB,SfmRrB,EAAqB,YAArB,EAAiC,aAAjC,EenR6C,IfmR7C,C;IelRQ,kBAAc,a;IAAd,iB;If8QR,gBAAgC,W;IEvN4B,U;IF0N5D,mBAAiC,CE1N2B,uBDxDrD,mDCwDqD,oCF0N3B,Y;IACjC,0BAAQ,WAAR,EAAqB,YAArB,EAAiC,aAAjC,EelRkD,IfkRlD,C;IejRI,W;EAAA,C;;;;;;;EAXR,yD;IAAA,wD;MAAA,uC;KAAA,iD;G;EAsDA,2C;IAAA,+C;IAEI,4BACI,0BAA0B,gBAA1B,uB;G;;;SADJ,Y;MAAA,gC;K;;kEAGA,mB;IACI,OAAA,sCAAe,eAAM,OAAQ,eAAd,C;G;gEAEnB,0B;IACI,OAAQ,sBAAa,KAAM,WAAnB,C;EACZ,C;;;;;;;EAVJ,uD;IAAA,sD;MAAA,qC;KAAA,+C;G;EAcA,yC;IAAA,6C;IAUI,4BACI,2BAA2B,YAA3B,MAAyC,+CAAzC,C;G;gEATJ,4B;IACI,IAAI,kBAAJ,C;MACI,MAAM,4BAAuB,iEAA8D,KAA9D,wBAAyE,SAAzE,MAAvB,C;KAEd,C;gEAEA,4B;IAA+D,yBAAkB,SAAlB,EAAmC,oBAAN,KAAM,CAAnC,C;G;;;SAE/D,Y;MAAA,gC;K;;gEAWA,mB;IACY,iBAAgB,e;IAAhB,0B;IhB8cZ,gBgB9cI,OhB8cY,wBAAe,UAAf,C;IAChB,SAAqB,I;;MgB9cb,YAAY,C;MACZ,aAAa,C;MACb,WAAW,C;YACN,OAAO,IAAP,C;QACK,YhB4cP,SgB5cmB,4BAAmB,eAAnB,C;QAAlB,c;eACI,C;YAAK,QhB2cV,SgB3ckB,0BAAiB,eAAjB,EAA6B,CAA7B,C;YAAb,K;eACA,C;YAAK,ShB0cV,SgB1cmB,0BAAiB,eAAjB,EAA6B,CAA7B,C;YAAd,K;eACA,C;YAAK,OhBycV,SgBzciB,0BAAiB,eAAjB,EAA6B,CAA7B,C;YAAZ,K;eACA,C;YAAK,yBAAkB,OAAlB,EhBwcV,SgBxcqC,0BAAiB,eAAjB,EAA6B,CAA7B,CAA3B,C;YAAL,K;eACA,C;YAAK,yBAAkB,SAAlB,EhBucV,SgBvcuC,0BAAiB,eAAjB,EAA6B,CAA7B,CAA7B,C;YAAL,K;eACA,C;YAAK,yBAAkB,SAAlB,EhBscV,SgBtcuC,0BAAiB,eAAjB,EAA6B,CAA7B,CAA7B,C;YAAL,K;eACA,C;YAAK,yBAAkB,aAAlB,EhBqcV,SgBrc2C,2BAAkB,eAAlB,EAA8B,CAA9B,CAAjC,C;YAAL,K;eACA,E;YAAgC,U;kBACxB,MAAM,4BAAuB,uBAAoB,KAA3C,C;;;MhBmc1B,yBgBhcI,gBAAW,KAAX,EAAkB,MAAlB,EAA0B,IAA1B,C;;MhBicN,gC;QACE,KAAK,C;QACL,MAAM,C;;QAJV,O;;;MAOI,IAAI,UAAJ,C;QAAgB,SAAU,sBAAa,UAAb,C;;IgBvd1B,6B;G;8DAoBJ,0B;IACY,iBAAgB,e;IC+V5B,gBD/VI,OC+VY,wBAAe,UAAf,C;IAChB,SAAqB,I;;MD9VT,IAAI,gBAAS,CAAb,C;QCgWR,SDhWwB,0BAAiB,+CAAkC,WAAnD,EAA+D,CAA/D,EAAkE,WAAlE,C;MAChB,IAAI,iBAAU,CAAd,C;QC+VR,SD/VyB,0BAAiB,+CAAkC,WAAnD,EAA+D,CAA/D,EAAkE,YAAlE,C;MACjB,IAAI,eAAQ,CAAZ,C;QC8VR,SD9VuB,0BAAiB,+CAAkC,WAAnD,EAA+D,CAA/D,EAAkE,UAAlE,C;;MC+VzB,gC;QACE,KAAK,C;QACL,MAAM,C;;QAJV,O;;;MAOI,IAAI,UAAJ,C;QAAgB,SAAU,sBAAa,UAAb,C;;EDjW9B,C;EAvC6C,oE;IACrC,e;IfwMR,cAAgC,W;IEvN4B,Q;IF0N5D,iBAAiC,CE1N2B,qBDxDrD,6DCwDqD,kCF0N3B,Y;IACjC,0Be5MqB,Of4MrB,EAAqB,UAArB,EAAiC,WAAjC,Ee5M2C,If4M3C,C;Ie3MQ,iB;IfuMR,gBAAgC,W;IEvN4B,U;IF0N5D,mBAAiC,CE1N2B,uBDxDrD,6DCwDqD,oCF0N3B,Y;IACjC,0Be3MqB,Qf2MrB,EAAqB,YAArB,EAAiC,aAAjC,Ee3M4C,If2M5C,C;Ie1MQ,iB;IfsMR,gBAAgC,W;IEvN4B,U;IF0N5D,mBAAiC,CE1N2B,uBDxDrD,6DCwDqD,oCF0N3B,Y;IACjC,0Be1MqB,Mf0MrB,EAAqB,YAArB,EAAiC,aAAjC,Ee1M0C,If0M1C,C;IezMQ,iB;IfqMR,gBAAgC,W;IEvN4B,U;IF0N5D,mBAAiC,CE1N2B,uBDxDrD,6DCwDqD,oCF0N3B,Y;IACjC,0BezMqB,OfyMrB,EAAqB,YAArB,EAAiC,aAAjC,EezM2C,IfyM3C,C;IexMQ,iB;IfoMR,gBAAgC,W;IEvN4B,U;IF0N5D,mBAAiC,CE1N2B,uBDxDrD,6DCwDqD,oCF0N3B,Y;IACjC,0BexMqB,SfwMrB,EAAqB,YAArB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"}